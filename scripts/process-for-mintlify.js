// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

console.log('üöÄ Processing X API SDK Documentation for Mintlify...');

// Mintlify configuration
const MINTLIFY_CONFIG = {
  outputDir: 'mintlify-docs',
  baseUrl: 'https://docs.x.com',
  title: 'X API SDK v0.2.1-beta',
  description: 'TypeScript SDK for the X API with comprehensive pagination, authentication, and streaming support.',
  version: '0.2.1-beta',
  githubUrl: 'https://github.com/xdevplatform/xsdk',
  logo: {
    light: '/logo-light.svg',
    dark: '/logo-dark.svg'
  }
};

// (Removed legacy category mappings and method groups)

// Helper function to generate Mintlify frontmatter
function generateFrontmatter(title, sidebarTitle = null) {
  // Clean up titles by removing generic type parameters for better readability
  const cleanTitle = (str) => {
    if (typeof str !== 'string') return str;
    return str
      .replace(/<.*?>/g, '')  // Remove all generic type parameters
      .replace(/Interface:\s+/, '')  // Remove "Interface:" prefix
      .replace(/Class:\s+/, '')  // Remove "Class:" prefix
      .replace(/\\/g, '')  // Remove any backslashes
      .replace(/\s+/g, ' ')  // Normalize whitespace
      .trim();
  };

  const frontmatter = {
    title: cleanTitle(title)
  };
  
  if (sidebarTitle) {
    frontmatter.sidebarTitle = cleanTitle(sidebarTitle);
  }
  
  // Use simple quoted strings for clean frontmatter
  return `---
title: "${cleanTitle(title)}"
${sidebarTitle ? `sidebarTitle: "${cleanTitle(sidebarTitle)}"` : ''}
---

`;
}

// Helper function to clean and format markdown content
function processMarkdownContent(content, title, currentFilePath, knownTargets) {
  // Remove TypeDoc-specific elements that don't work well in Mintlify
  content = content
    // Remove TypeDoc navigation elements
    .replace(/\[\[include:.*?\]\]/g, '')
    .replace(/\[\[include-start:.*?\]\]/g, '')
    .replace(/\[\[include-end:.*?\]\]/g, '')
    
    // Fix code block formatting
    .replace(/```typescript\n/g, '```typescript\n')
    .replace(/```javascript\n/g, '```javascript\n')
    
    // Remove TypeDoc breadcrumbs (README/Exports)
    .replace(/^\[[^\]]+\]\([^\)]+\)\s*\/\s*\[Exports\]\([^\)]+\)\s*\/.*\n?/m, '')
    // Remove modules breadcrumb variant: [..](..)/ Exports
    .replace(/^\[[^\]]+\]\([^\)]+\)\s*\/\s*Exports\s*\n?/m, '')
    // Fix internal links ‚Üí absolute Mintlify paths, preserve TypeDoc subdirs
    // Examples:
    // [Client](classes/Client.md) ‚Üí /xdks/typescript/reference/classes/Client
    // [deleteSubscription](AccountActivityClient.md#deletesubscription) ‚Üí /xdks/typescript/reference/AccountActivityClient#deletesubscription
    .replace(/\[([^\]]+)\]\(([^)#]+?)(?:\.(?:md|mdx))?(#[^)]+)?\)/g, (match, text, rawLinkPath, hash) => {
      // Skip absolute URLs (http, https, mailto, tel)
      if (/^(?:https?:|mailto:|tel:)/i.test(rawLinkPath)) {
        return match;
      }
      const anchor = hash || '';
      const linkPath = rawLinkPath.replace(/\.(?:md|mdx)$/i, '');
      const currentDir = currentFilePath ? currentFilePath.substring(0, currentFilePath.lastIndexOf('/')) : '';
      // Normalize relative paths
      const joined = path.posix.normalize(path.posix.join(currentDir || '', linkPath));
      let targetPath = joined.replace(/^\.\/?/, '').replace(/^docs\//, '');
      // If no directory segment and a known target exists for this base name, use it
      if (!targetPath.includes('/') && knownTargets && knownTargets.has(targetPath)) {
        targetPath = `${knownTargets.get(targetPath)}/${targetPath}`;
      }
      return `[${text}](/xdks/typescript/reference/${targetPath}${anchor})`;
    })
    
    // Fix method signatures
    .replace(/### (.*?)\(/g, '### `$1`(')
    
    // Add proper spacing
    .replace(/\n\n\n+/g, '\n\n')
    
    // Fix parameter formatting
    .replace(/\*\*@param\s+(\w+)\s+(.*?)\*\*/g, '**@param** `$1` - $2')
    // Replace package placeholder with real npm package
    .replace(/@your-org\/x-api-sdk/g, '@xdevplatform/xdk')
    .replace(/from\s+['"]x-api-sdk['"]/g, "from '@xdevplatform/xdk'")
    .replace(/\*\*@returns\s+(.*?)\*\*/g, '**@returns** $1')
    .replace(/\*\*@throws\s+(.*?)\*\*/g, '**@throws** $1');

  // Remove the first H1 header to avoid duplicate titles (frontmatter title will be used)
  content = content.replace(/^\s*#\s+[^\n]+\n+/, '');

  // Escape generic type angle brackets like PaginatedResponse<T> to avoid MDX JSX parsing
  content = content.replace(/\b([A-Z][A-Za-z0-9_]*)<([^>\n]+)>/g, (m, name, inner) => {
    const escapedInner = inner.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return `${name}&lt;${escapedInner}&gt;`;
  });

  // Remove explicit Table of contents blocks; Mintlify renders a sidebar TOC automatically
  content = content.replace(/(^##\s+Table of contents\n[\s\S]*?)(?=^##\s+|^#\s+|\Z)/gmi, '');

  // Convert Properties sections to Mintlify components (ResponseField/ParamField/Expandable)
  // Check if this is an interface or class file
  const isInterfaceOrClass = currentFilePath && (
    currentFilePath.includes('interfaces/') || 
    currentFilePath.includes('classes/')
  );
  
  if (isInterfaceOrClass && content.includes('## Properties')) {
    const useParamField = /Options\b/i.test(currentFilePath);
    const fieldTag = useParamField ? 'ParamField' : 'ResponseField';
    
    // Helper to escape type strings for HTML attributes
    const escapeType = (type) => String(type)
      .replace(/\"/g, '"')
      .replace(/"/g, '&quot;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\{/g, '&#123;')
      .replace(/\}/g, '&#125;');
    
    // Helper to parse inline object type (e.g., "{ name?: string; age: number }")
    const parseInlineObject = (objStr) => {
      // Remove outer braces and array brackets
      let cleaned = objStr.trim().replace(/^\{/, '').replace(/\}\s*\[\]?\s*$/, '').trim();
      if (!cleaned) return [];
      
      const props = [];
      // Split by semicolons, but be careful with nested objects
      let depth = 0;
      let current = '';
      const parts = [];
      
      for (let i = 0; i < cleaned.length; i++) {
        const char = cleaned[i];
        if (char === '{') depth++;
        else if (char === '}') depth--;
        else if (char === ';' && depth === 0) {
          parts.push(current.trim());
          current = '';
          continue;
        }
        current += char;
      }
      if (current.trim()) parts.push(current.trim());
      
      for (const part of parts) {
        // Match: name?: type or name: type
        const match = part.match(/^\s*([^:?]+?)\??\s*:\s*(.+?)\s*$/);
        if (match) {
          const propName = match[1].trim();
          let propType = match[2].trim();
          const isOptional = part.includes('?') && !propType.includes('?');
          
          // Clean up type (remove extra braces if present)
          propType = propType.replace(/^\{/, '').replace(/\}$/, '');
          
          props.push({
            name: propName,
            type: propType,
            optional: isOptional
          });
        }
      }
      return props;
    };
    
    // Convert markdown table to Expandable with child fields
    const tableToExpandable = (tableLines, tagName) => {
      const children = [];
      for (const line of tableLines) {
        const trimmed = line.trim();
        // Skip header/separator rows
        if (/^\|\s*:?-{2,}\s*\|/.test(trimmed) || /^\|\s*Name\s*\|\s*Type\s*\|\s*$/i.test(trimmed)) continue;
        const m = trimmed.match(/^\|\s*`?([^`|]+?)`?\s*\|\s*(.+?)\s*\|$/);
        if (!m) continue;
        const fname = m[1].trim().replace(/\?$/, '');
        let ftype = m[2].trim();
        const isOptional = m[1].includes('?');
        
        // Remove ALL backticks and backslashes from type for parsing
        // Backticks might be around the whole type or around individual parts
        ftype = ftype.replace(/`/g, '').replace(/\\/g, '');
        
        // Check if type is Object[] with inline definition
        if (/^\{[\s\S]*\}\s*\[\]\s*$/.test(ftype)) {
          const objProps = parseInlineObject(ftype);
          if (objProps.length > 0) {
            const nested = objProps.map(p => {
              const req = p.optional ? '' : ' required';
              const cleanPType = p.type.replace(/\}\s*\[\]\s*$/, '').trim();
              return `<${tagName} name="${p.name}" type="${escapeType(cleanPType)}"${req}>\n</${tagName}>`;
            }).join('\n\n');
            children.push(`<${tagName} name="${fname}" type="Object[]"${isOptional ? '' : ' required'}>\n<Expandable title="properties">\n${nested}\n</Expandable>\n</${tagName}>`);
          } else {
            children.push(`<${tagName} name="${fname}" type="Object[]"${isOptional ? '' : ' required'}>\n</${tagName}>`);
          }
        } else if (/^\{[\s\S]*\}$/.test(ftype)) {
          // Nested object
          const objProps = parseInlineObject(ftype);
          if (objProps.length > 0) {
            const nested = objProps.map(p => {
              const req = p.optional ? '' : ' required';
              return `<${tagName} name="${p.name}" type="${escapeType(p.type.trim())}"${req}>\n</${tagName}>`;
            }).join('\n\n');
            children.push(`<${tagName} name="${fname}" type="Object"${isOptional ? '' : ' required'}>\n<Expandable title="properties">\n${nested}\n</Expandable>\n</${tagName}>`);
          } else {
            children.push(`<${tagName} name="${fname}" type="Object"${isOptional ? '' : ' required'}>\n</${tagName}>`);
          }
        } else {
          // Simple type
          const cleanType = ftype;
          children.push(`<${tagName} name="${fname}" type="${escapeType(cleanType)}"${isOptional ? '' : ' required'}>\n</${tagName}>`);
        }
      }
      return children;
    };
    
    // Convert each property section
    // Find Properties section - match from ## Properties to end of content or next ## section
    const propsIndex = content.indexOf('## Properties');
    if (propsIndex !== -1) {
      // Find where Properties section ends (next ## or end of content)
      const afterProps = content.substring(propsIndex + '## Properties'.length);
      const nextSection = afterProps.match(/^\s*\n+(.*?)(?=^##\s+|$)/s);
      if (!nextSection) return content;
      
      const propsSection = nextSection[1];
      const convertedProps = [];
      
      // Match each property using regex - be more flexible with matching
      // Split by ### headers first to ensure we get complete property blocks
      const propBlocks = propsSection.split(/(?=^###\s+)/m).filter(b => b.trim().startsWith('###'));
      
      for (const propBlock of propBlocks) {
        const nameMatch = propBlock.match(/^###\s+([^\n]+)\n+/);
        if (!nameMatch) continue;
        
        const propName = nameMatch[1].trim();
        const propBody = propBlock.substring(nameMatch[0].length);
          
          // Check if optional
          const isOptional = /‚Ä¢\s*`?Optional`?/.test(propBody);
          
          // Extract type first (before description extraction)
          // Match: ‚Ä¢ Optional **name**: `type` or ‚Ä¢ **name**: type (with or without backticks)
          // Handle cases like: `Object`, `\{ ... \}[]`, or inline types without backticks
          const typePattern = /:\s*(?:`([^`]+)`|([^\n]+?))(?:\s*\n|$)/;
          const typeMatch = propBody.match(typePattern);
          let typeStr = 'any';
          
          if (typeMatch) {
            // Prefer backtick-wrapped type, otherwise use unwrapped
            typeStr = (typeMatch[1] || typeMatch[2] || '').trim();
          }
          
          // Clean up type string - remove backslashes, backticks, and extract from markdown links
          // Handle markdown link format: [`Type`](link) -> just use "Type"
          typeStr = typeStr.replace(/\[`([^`]+)`\]\([^\)]+\)/g, '$1');
          typeStr = typeStr.replace(/`/g, '').replace(/\\/g, '');
          
          // Extract description (text after type line, before "Type declaration" or "Defined in")
          // First, find where the type line ends
          const typeLineEnd = propBody.indexOf('\n', propBody.indexOf(':'));
          const afterTypeLine = typeLineEnd !== -1 ? propBody.substring(typeLineEnd + 1) : propBody;
          
          // Then extract just the description part (before Type declaration or Defined in)
          const descMatch = afterTypeLine.match(/^([\s\S]*?)(?:\n####\s+Type declaration|\n####\s+Defined in|\n___|\n###|$)/);
          let description = descMatch ? descMatch[1].trim() : '';
          
          // Remove any leftover type line fragments
          description = description
            .replace(/^‚Ä¢\s*`?Optional`?\s*\*\*[^*]+\*\*:\s*`?[^`\n]+`?\s*\n*/, '')
            .replace(/^‚Ä¢\s*\*\*[^*]+\*\*:\s*`?[^`\n]+`?\s*\n*/, '')
            .replace(/^‚Ä¢\s*`?Optional`?\s*$/, '')
            .trim();
          
          // Check if there's a Type declaration table
          const typeDeclMatch = propBody.match(/####\s+Type declaration\s*\n+([\s\S]*?)(?=\n####\s+Defined in|\n___|\n###|$)/);
          
          if (typeDeclMatch) {
            // Has table - convert to Expandable
            const tableText = typeDeclMatch[1];
            const tableLines = tableText.split('\n').filter(l => l.trim().startsWith('|'));
            const children = tableToExpandable(tableLines, fieldTag);
            
            if (children.length > 0) {
              const finalType = typeStr === 'Object' || typeStr.includes('Object') ? 'Object' : typeStr;
              const requiredAttr = isOptional ? '' : ' required';
              const expandableContent = children.join('\n\n');
              const descPart = description ? `${description}\n\n` : '';
              convertedProps.push(`<${fieldTag} name="${propName}" type="${escapeType(finalType)}"${requiredAttr}>\n${descPart}<Expandable title="properties">\n${expandableContent}\n</Expandable>\n</${fieldTag}>`);
            } else {
              const requiredAttr = isOptional ? '' : ' required';
              const descPart = description ? `${description}\n\n` : '';
              convertedProps.push(`<${fieldTag} name="${propName}" type="${escapeType(typeStr)}"${requiredAttr}>\n${descPart}</${fieldTag}>`);
            }
          } else if (/^\{[\s\S]*\}\s*\[\]\s*$/.test(typeStr.replace(/`/g, ''))) {
            // Object[] with inline definition - remove backticks and backslashes
            const cleanTypeStr = typeStr.replace(/`/g, '').replace(/\\/g, '');
            const objProps = parseInlineObject(cleanTypeStr);
            
            // Clean description - remove any type definition remnants
            description = description.replace(/\{[\s\S]*\}\s*\[\]\s*$/, '').trim();
            
            if (objProps.length > 0) {
              const nested = objProps.map(p => {
                const req = p.optional ? '' : ' required';
                const cleanPType = p.type.replace(/\}\s*\[\]\s*$/, '').trim();
                return `<${fieldTag} name="${p.name}" type="${escapeType(cleanPType)}"${req}>\n</${fieldTag}>`;
              }).join('\n\n');
              const requiredAttr = isOptional ? '' : ' required';
              const descPart = description ? `${description}\n\n` : '';
              convertedProps.push(`<${fieldTag} name="${propName}" type="Object[]"${requiredAttr}>\n${descPart}<Expandable title="properties">\n${nested}\n</Expandable>\n</${fieldTag}>`);
            } else {
              const requiredAttr = isOptional ? '' : ' required';
              const descPart = description ? `${description}\n\n` : '';
              convertedProps.push(`<${fieldTag} name="${propName}" type="Object[]"${requiredAttr}>\n${descPart}</${fieldTag}>`);
            }
          } else {
            // Simple type or reference type
            const cleanType = typeStr.replace(/^`|`$/g, '').replace(/\\/g, '');
            const requiredAttr = isOptional ? '' : ' required';
            const descPart = description ? `${description}\n\n` : '';
            convertedProps.push(`<${fieldTag} name="${propName}" type="${escapeType(cleanType)}"${requiredAttr}>\n${descPart}</${fieldTag}>`);
          }
      }
      
      if (convertedProps.length > 0) {
        // Replace the Properties section with converted content
        const convertedContent = convertedProps.join('\n\n');
        const beforeProps = content.substring(0, propsIndex);
        const afterPropsStart = propsIndex + '## Properties'.length + nextSection[0].length;
        const rest = content.substring(afterPropsStart);
        content = beforeProps + '## Properties\n\n' + convertedContent + '\n' + rest;
      }
    }
    
    // Clean up "Defined in" sections and separators
    content = content
      .replace(/^####\s+Defined in[\s\S]*?(?=^###\s+|^##\s+|$)/gm, '')
      .replace(/^___\s*$/gm, '');

    // Escape '<' inside component blocks to avoid MDX JSX parse issues in text like '<='
    // But preserve JSX tags like <Expandable>, <ResponseField>, etc.
    content = content
      .replace(/(<ResponseField[\s\S]*?>)([\s\S]*?)(<\/ResponseField>)/g, (m, open, inner, close) => {
        // Escape '<' only when it's NOT part of a JSX tag (like <Expandable> or </Expandable>)
        // Pattern: < followed by either a letter (JSX tag start) or /letter (JSX closing tag)
        // Escape everything else like '<=' or '< number'
        const escaped = inner.replace(/<(?![A-Za-z/])/g, '&lt;');
        return open + escaped + close;
      })
      .replace(/(<ParamField[\s\S]*?>)([\s\S]*?)(<\/ParamField>)/g, (m, open, inner, close) => {
        const escaped = inner.replace(/<(?![A-Za-z/])/g, '&lt;');
        return open + escaped + close;
      });
  }

  return content;
}

// Helper function to determine category from file path
function getCategoryFromPath(filePath) {
  if (filePath.includes('classes/Client')) return 'Getting Started';
  if (filePath.includes('classes/Paginator')) return 'Core Features';
  if (filePath.includes('stream_client')) return 'Core Features';
  if (filePath.includes('interfaces/')) return 'API Reference';
  
  return 'API Reference';
}

// Main processing function
async function processDocs() {
  try {
    // First, try to generate the documentation, but skip if it fails (e.g., Node version mismatch)
    console.log('üìö Generating documentation...');
    try {
      execSync('npm run docs:build', { stdio: 'inherit' });
    } catch (error) {
      console.log('‚ö†Ô∏è  TypeDoc generation failed (likely Node version issue), using existing docs if available...');
      if (!fs.existsSync('docs') || fs.readdirSync('docs').length === 0) {
        throw new Error('No documentation found and TypeDoc generation failed. Please upgrade Node.js to 16+ or generate docs manually.');
      }
      console.log('‚úÖ Using existing documentation files');
    }
    
    // Create output directory
    const outputDir = MINTLIFY_CONFIG.outputDir;
    if (fs.existsSync(outputDir)) {
      fs.rmSync(outputDir, { recursive: true });
    }
    fs.mkdirSync(outputDir, { recursive: true });
    
    // Create subdirectories with xdks/typescript prefix
    fs.mkdirSync(path.join(outputDir, 'xdks', 'typescript', 'reference'), { recursive: true });
    
    console.log('üìù Processing markdown files...');
    
    // Process all markdown files
    const docsDir = 'docs';
    
    // Recursive function to get all files (for Node.js < 18)
    function getAllFiles(dir, fileList = []) {
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        const filePath = path.join(dir, file);
        if (fs.statSync(filePath).isDirectory()) {
          getAllFiles(filePath, fileList);
        } else if (file.endsWith('.md')) {
          // Store relative path from docsDir
          fileList.push(path.relative(docsDir, filePath));
        }
      });
      return fileList;
    }
    
    const files = getAllFiles(docsDir);
    
    // Build map of known targets: baseName -> subdirectory (classes/interfaces/modules/enums)
    const knownTargets = new Map();
    for (const f of files) {
      if (typeof f === 'string' && f.endsWith('.md')) {
        const base = path.basename(f, '.md');
        const dir = path.dirname(f).replace(/^\.$/, '');
        if (!knownTargets.has(base) && dir && dir !== 'docs') {
          knownTargets.set(base, dir);
        }
      }
    }
    
    const processedFiles = [];
    const navigation = {
      'Getting Started': [],
      'Core Features': [],
      'API Reference': [],
      'Authentication': [],
      'Utilities': []
    };
    
    for (const file of files) {
      if (file.endsWith('.md') && file !== 'README.md') {
        const filePath = path.join(docsDir, file);
        const content = fs.readFileSync(filePath, 'utf8');
        
        // Extract title from content or filename
        let title = path.basename(file, '.md');
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch) {
          title = titleMatch[1];
        }
        
        // Clean up title (keep original class/interface names without inserting spaces)
        title = title
          .replace(/^Class\s+/, '')
          .replace(/^Interface\s+/, '')
          .replace(/^Type\s+/, '')
          .trim();
        
        const category = getCategoryFromPath(file);
        const processedContent = processMarkdownContent(content, title, file, knownTargets);
        
    // Generate frontmatter with sidebarTitle
    const frontmatter = generateFrontmatter(title, title);
        const finalContent = frontmatter + processedContent;
        
        // Determine output path with xdks/typescript prefix, preserving TypeDoc subdirectories
        const baseName = path.basename(file, '.md');
        const subDir = path.dirname(file); // e.g., classes, interfaces, enums
        const targetDir = path.join(outputDir, 'xdks', 'typescript', 'reference', subDir);
        fs.mkdirSync(targetDir, { recursive: true });
        const outputPath = path.join(targetDir, `${baseName}.mdx`);
        
        // Write processed file
        fs.writeFileSync(outputPath, finalContent);
        processedFiles.push({
          title,
          category,
          path: outputPath,
          originalPath: file
        });
        
        // Add to navigation with xdks/typescript prefix (preserve subdirectory)
        if (navigation[category]) {
          const relativeRefPath = path.join(subDir, baseName).replace(/\\/g, '/');
          navigation[category].push({
            title,
            url: `xdks/typescript/reference/${relativeRefPath}`
          });
        }
      }
    }
    
    // Create high-level documentation pages
    console.log('üìÑ Creating high-level documentation pages...');
    
    // Overview page
    const overviewContent = `---
title: "TypeScript XDK"
sidebarTitle: "Overview"
---

A comprehensive TypeScript SDK for the X API (formerly Twitter API) with advanced features including smart pagination, multiple authentication methods, real-time streaming, and full type safety.

## Key Features

- **üîê Authentication**: User Context (OAuth1.0a, OAuth2.0), and App-Only (Bearer token) authentication
- **üîÑ Pagination**: Automatic pagination with async iteration support
- **üì° Streaming**: Event-driven streaming with automatic reconnection
- **üìö Type Safety**: Complete TypeScript definitions for all endpoints and parameters
- **üéØ Full X API Support**: Users, Posts, Lists, Bookmarks, Communities, and more

## Quick Start

<CodeGroup dropdown>

\`\`\`typescript quickstart.ts theme={null}
import { 
    Client, 
    type ClientConfig,
    type Users
} from '@xdevplatform/xdk';

const config: ClientConfig = { bearerToken: 'your-bearer-token' };

const client: Client = new Client(config);

async function main(): Promise<void> {
  const userResponse: Users.GetByUsernameResponse = await client.users.getByUsername('XDevelopers');
  const username: string = userResponse.data?.username!;
  console.log(username);
}

main();
\`\`\`

\`\`\`javascript quickstart.js theme={null}
import { Client } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: 'your-bearer-token' });

const userResponse = await client.users.getByUsername('XDevelopers');
const username = userResponse.data.username;
console.log(username);
\`\`\`

</CodeGroup>

## What's Next?

- [Installation Guide](/xdks/typescript/install) - Set up the SDK in your project
- [Authentication](/xdks/typescript/authentication) - Learn about different auth methods
- [Pagination](/xdks/typescript/pagination) - Learn about data pagination
- [Streaming](/xdks/typescript/streaming) - Learn about real-time data streaming
- [API Reference](/xdks/typescript/reference/Client) - Read the complete API documentation
`;

    fs.writeFileSync(path.join(outputDir, 'xdks', 'typescript', 'overview.mdx'), overviewContent);

    // Install page
    const installContent = `---
title: "Installation"
sidebarTitle: "Installation"
---

Get started with the TypeScript SDK for X API in your project.

## Install

<CodeGroup>

\`\`\`bash npm theme={null}
npm install @xdevplatform/xdk
\`\`\`

\`\`\`bash yarn theme={null}
yarn add @xdevplatform/xdk
\`\`\`

\`\`\`bash pnpm theme={null}
pnpm add @xdevplatform/xdk
\`\`\`

</CodeGroup>

## TypeScript Support

The SDK is written in TypeScript and includes full type definitions. No additional type packages are required.

## Requirements

- Node.js 16+ 
- TypeScript 4.5+ (if using TypeScript)

## Next Steps

- [Authentication](/xdks/typescript/authentication) - Set up authentication
- [Quick Start](/xdks/typescript/overview) - Your first API call
`;

    fs.writeFileSync(path.join(outputDir, 'xdks', 'typescript', 'install.mdx'), installContent);

    // Authentication page
    const authContent = `---
title: "Authentication"
sidebarTitle: "Authentication"
---

The TypeScript SDK supports multiple authentication methods for different use cases.

## Bearer Token (App-Only Auth)

For read-only operations and public data access:

<CodeGroup dropdown>

\`\`\`typescript quickstart.ts theme={null}
import { 
  Client, 
  type ClientConfig,
  type Users
} from '@xdevplatform/xdk';

const config: ClientConfig = { bearerToken: 'your-bearer-token' };

const client: Client = new Client(config);

async function main(): Promise<void> {
  const userResponse: Users.GetByUsernameResponse = await client.users.getByUsername('XDevelopers');
  const username: string = userResponse.data?.username!;
  console.log(username);
}

main();
\`\`\`

\`\`\`javascript quickstart.js theme={null}
import { Client } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: 'your-bearer-token' });

const userResponse = await client.users.getByUsername('XDevelopers');
const username = userResponse.data.username;
console.log(username);
\`\`\`

</CodeGroup>

## OAuth 1.0a (User Context)

For legacy applications or specific use cases:

<CodeGroup dropdown>

\`\`\`typescript oauth1.ts theme={null}
import { 
  Client, 
  OAuth1,
  type OAuth1Config,
  type ClientConfig,
  type Users
} from '@xdevplatform/xdk';

const oauth1Config: OAuth1Config = {
  apiKey: 'your-api-key',
  apiSecret: 'your-api-secret',
  accessToken: 'user-access-token',
  accessTokenSecret: 'user-access-token-secret'
};

const oauth1: OAuth1 = new OAuth1(oauth1Config);

const config: ClientConfig = {
  oauth1: oauth1,
};

const client: Client = new Client(config);

async function main(): Promise<void> {
  const response: Users.GetMeResponse = await client.users.getMe();

  const me = response.data;
  console.log(me);
}

main();

\`\`\`

\`\`\`javascript oauth1.js theme={null}
import { 
  Client, 
  type ClientConfig,
  type Users
} from '@xdevplatform/xdk';

const config: ClientConfig = { bearerToken: 'your-bearer-token' };

const client: Client = new Client(config);

async function main(): Promise<void> {
  const userResponse: Users.GetByUsernameResponse = await client.users.getByUsername('XDevelopers');
  const username: string = userResponse.data?.username!;
  console.log(username);
}

main();

\`\`\`

</CodeGroup>

## OAuth 2.0 (User Context)

For user-specific operations:

<CodeGroup dropdown>

\`\`\`typescript oauth2.ts theme={null}
import { 
  Client, 
  OAuth2,
  generateCodeVerifier,
  generateCodeChallenge,
  type OAuth2Config,
  type ClientConfig,
  type OAuth2Token
} from '@xdevplatform/xdk';

(async (): Promise<void> => {
  const oauth2Config: OAuth2Config = {
    clientId: 'your-client-id',
    clientSecret: 'your-client-secret',
    redirectUri: 'https://example.com',
    scope: ['tweet.read', 'users.read', 'offline.access'],
  };

  const oauth2: OAuth2 = new OAuth2(oauth2Config);

  const state: string = 'example-state';
  const codeVerifier: string = generateCodeVerifier();
  const codeChallenge: string = await generateCodeChallenge(codeVerifier);
  
  oauth2.setPkceParameters(codeVerifier, codeChallenge);
  
  const authUrl: string = await oauth2.getAuthorizationUrl(state);

  const tokens: OAuth2Token = await oauth2.exchangeCode(authCode, codeVerifier);

  const config: ClientConfig = {
    accessToken: tokens.access_token,
  };

  const client: Client = new Client(config);
});

\`\`\`

\`\`\`javascript oauth2.js theme={null}
import { Client, OAuth2, generateCodeVerifier, generateCodeChallenge } from '@xdevplatform/xdk';

(async () => {
  const oauth2 = new OAuth2({
    clientId: 'your-client-id',
    clientSecret: 'your-client-secret',
    redirectUri: 'https://example.com',
    scope: ['tweet.read', 'users.read', 'offline.access'],
  });

  const state = 'example-state';
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = await generateCodeChallenge(codeVerifier);
  oauth2.setPkceParameters(codeVerifier, codeChallenge);
  const authUrl = await oauth2.getAuthorizationUrl(state);

  const tokens = await oauth2.exchangeCode(authCode, codeVerifier);

  const client = new Client({ accessToken: tokens.access_token });

  const response = await client.users.getMe();
  const me = response.data;
  console.log(me);
});
\`\`\`

</CodeGroup>

## Environment Variables

Store sensitive credentials in environment variables:

\`\`\`bash
# .env
X_API_BEARER_TOKEN=your-bearer-token
X_API_CLIENT_ID=your-client-id
X_API_CLIENT_SECRET=your-client-secret
\`\`\`

<CodeGroup dropdown>

\`\`\`typescript env.ts theme={null}
import { Client } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: process.env.X_API_BEARER_TOKEN });
\`\`\`

\`\`\`javascript env.js theme={null}
import { Client } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: process.env.X_API_BEARER_TOKEN });
\`\`\`

</CodeGroup>
`;

    fs.writeFileSync(path.join(outputDir, 'xdks', 'typescript', 'authentication.mdx'), authContent);

    // Pagination page
    const paginationContent = `---
title: "Pagination"
sidebarTitle: "Pagination"
---

The SDK provides generic paginator utilities you can use with any endpoint that returns paginated responses. Methods return plain responses; you wrap them with a paginator.

### Basic Pagination

<CodeGroup dropdown>

\`\`\`typescript quick-start.ts theme={null}
import { Client, UserPaginator, PaginatedResponse, Schemas } from '@xdevplatform/xdk';

const client: Client = new Client({ bearerToken: 'your-bearer-token' });

// Wrap any list endpoint with proper typing
const followers: UserPaginator = new UserPaginator(
  async (token?: string): Promise<PaginatedResponse<Schemas.User>> => {
    const res = await client.users.getFollowers('<userId>', {
      maxResults: 100,
      paginationToken: token,
      userFields: ['id','name','username'],
    });
    return { 
      data: res.data ?? [], 
      meta: res.meta, 
      includes: res.includes, 
      errors: res.errors 
    };
  }
);
\`\`\`

\`\`\`javascript quick-start.js theme={null}
import { Client } from '@xdevplatform/xdk';
import { UserPaginator } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: 'your-bearer-token' });

const followers = new UserPaginator(async (token) => {
  const res = await client.users.getFollowers('<userId>', {
    maxResults: 100,
    paginationToken: token,
    userFields: ['id','name','username'],
  });
  return { data: res.data ?? [], meta: res.meta, includes: res.includes, errors: res.errors };
});
\`\`\`

</CodeGroup>

### Manual paging

<CodeGroup>

\`\`\`typescript manual.ts theme={null}
import { UserPaginator, Schemas } from '@xdevplatform/xdk';

await followers.fetchNext();          // first page
while (!followers.done) {
  await followers.fetchNext();        // subsequent pages
}

const userCount: number = followers.users.length;  // all fetched users
const firstUser: Schemas.User | undefined = followers.users[0];
const nextToken: string | undefined = followers.meta?.next_token;
\`\`\`

\`\`\`javascript manual.js theme={null}
await followers.fetchNext();
while (!followers.done) await followers.fetchNext();
console.log(followers.items.length);
\`\`\`

</CodeGroup>

### Async iteration

<CodeGroup>

\`\`\`typescript async.ts theme={null}
import { Schemas } from '@xdevplatform/xdk';

for await (const user of followers) {
  const typedUser: Schemas.User = user;
  console.log(typedUser.username);  // fully typed access
}
\`\`\`

\`\`\`javascript async.js theme={null}
for await (const user of followers) {
  console.log(user.username);
}
\`\`\`

</CodeGroup>

### Next page as a new instance

<CodeGroup>

\`\`\`typescript next.ts theme={null}
import { UserPaginator } from '@xdevplatform/xdk';

await followers.fetchNext();
if (!followers.done) {
  const page2: UserPaginator = await followers.next(); // independent paginator starting at next page
  await page2.fetchNext();
  console.log(page2.users.length);  // items from second page
}
\`\`\`

\`\`\`javascript next.js theme={null}
await followers.fetchNext();
if (!followers.done) {
  const page2 = await followers.next();
  await page2.fetchNext();
}
\`\`\`

</CodeGroup>

### Error handling and rate limits

<CodeGroup>

\`\`\`typescript errors.ts theme={null}
import { UserPaginator, Schemas } from '@xdevplatform/xdk';

try {
  for await (const item of followers) {
    const user: Schemas.User = item;
    // process user...
  }
} catch (err: unknown) {
  if (followers.rateLimited) {
    console.error('Rate limited, backoff required');
    // backoff / retry later
  } else {
    console.error('Pagination error:', err);
    throw err;
  }
}
\`\`\`

\`\`\`javascript errors.js theme={null}
try {
  for await (const item of followers) {
    // ...
  }
} catch (err) {
  if (followers.rateLimited) {
    // backoff / retry later
  } else {
    throw err;
  }
}
\`\`\`

</CodeGroup>
`;
fs.writeFileSync(path.join(outputDir, 'xdks', 'typescript', 'pagination.mdx'), paginationContent);

// Streaming page
const streamingContent = `---
title: "Streaming"
sidebarTitle: "Streaming"
---

The TypeScript SDK provides real-time streaming capabilities for live data feeds.

## Basic Streaming

Connect to real-time sampled posts:

<CodeGroup>

\`\`\`typescript stream.ts theme={null}
import { Client } from '@xdevplatform/xdk';

const client: Client = new Client({ bearerToken: 'your-bearer-token' });

// 1% sampled public posts
const stream = await client.stream.postsSample({
  tweetFields: ['id','text','created_at'],
  expansions: ['author_id'],
  userFields: ['id','username','name']
});

// Listen to events
stream.on('data', (event) => {
  // event is the parsed JSON line (data/includes/matching_rules)
  console.log('New data:', event);
});

stream.on('error', (e) => console.error('Stream error:', e));
stream.on('close', () => console.log('Stream closed'));
\`\`\`

\`\`\`javascript stream.js theme={null}
import { Client } from '@xdevplatform/xdk';

const client = new Client({ bearerToken: 'your-bearer-token' });
const stream = await client.stream.postsSample({ tweetfields: ['id','text'] });

stream.on('data', (event) => {
  console.log('New data:', event);
});
stream.on('error', (e) => console.error('Stream error:', e));
stream.on('close', () => console.log('Stream closed'));
\`\`\`

</CodeGroup>

## Async Iteration

Consume the stream with async iteration:

<CodeGroup>

\`\`\`typescript async.ts theme={null}
const stream = await client.stream.postsSample();
for await (const event of stream) {
  // Each event is a parsed JSON line (data/includes/matching_rules)
  console.log(event);
}
\`\`\`

\`\`\`javascript async.js theme={null}
const stream = await client.stream.postsSample();
for await (const event of stream) {
  console.log(event);
}
\`\`\`

</CodeGroup>

## Stream Management

Control lifecycle from the event-driven stream:

\`\`\`typescript
// Close the stream
stream.close();

// Auto-reconnect (if enabled by your wrapper)
// The default EventDrivenStream exposes basic reconnect hooks
\`\`\`

## Error Handling

Handle streaming errors and reconnections:

\`\`\`typescript
stream.on('error', (event) => {
  const err = event.error || event;
  console.error('Stream error:', err);
});

stream.on('keepAlive', () => {
  // heartbeat event
});
\`\`\`
`;
fs.writeFileSync(path.join(outputDir, 'xdks', 'typescript', 'streaming.mdx'), streamingContent);
    
    // Create navigation structure for integration into existing Mintlify site
    console.log('‚öôÔ∏è Creating navigation structure...');

    // Build API Reference groups from the generated files on disk
    const refRoot = path.join(outputDir, 'xdks', 'typescript', 'reference');
    const classesDir = path.join(refRoot, 'classes');
    const interfacesDir = path.join(refRoot, 'interfaces');

    const listFilesNoExt = (dir) => {
      try {
        return fs.readdirSync(dir)
          .filter(f => f.endsWith('.mdx'))
          .map(f => `xdks/typescript/reference/${path.basename(dir)}/${path.basename(f, '.mdx')}`);
      } catch (_) {
        return [];
      }
    };

    const classesPages = listFilesNoExt(classesDir);
    const interfacesPages = listFilesNoExt(interfacesDir);

    // Build sub-groups for Classes and Interfaces
    const MODULE_PREFIXES = [
      'AccountActivity','Activity','Communities','CommunityNotes','Compliance','Connections',
      'DirectMessages','General','Lists','Media','Posts','Spaces','Stream','Trends','Usage',
      'Users','Webhooks','Http','OAuth','Client','Paginator','EventDrivenStream','StreamClient'
    ];

    function groupPages(pages, kind) {
      const buckets = new Map();
      for (const p of pages) {
        const name = p.split('/').pop();
        let group = null;
        for (const pref of MODULE_PREFIXES) {
          if (name.startsWith(pref)) { group = pref; break; }
        }
        if (!group) {
          if (kind === 'classes') {
            if (/Client$/.test(name)) group = 'Clients';
            else if (/Stream/i.test(name)) group = 'Streaming';
            else if (/Paginator$/.test(name)) group = 'Pagination';
            else group = 'Core';
          } else {
            // interfaces
            group = 'Misc';
          }
        }
        if (!buckets.has(group)) buckets.set(group, []);
        buckets.get(group).push(p);
      }
      // Sort pages within groups alphabetically
      for (const [k, arr] of buckets) arr.sort();
      // Convert to [{group, pages}]
      return Array.from(buckets.entries()).sort((a,b)=>a[0].localeCompare(b[0])).map(([group, pages]) => ({ group, pages }));
    }

    const classGroups = groupPages(classesPages, 'classes');
    const interfaceGroups = groupPages(interfacesPages, 'interfaces');

    // Overwrite modules.mdx with an organized, expandable structure
    const modulesOut = path.join(refRoot, 'modules.mdx');
    // Derive original TypeDoc modules title from docs/modules.md
    let typedocModulesTitle = 'Modules';
    try {
      const rawModules = fs.readFileSync(path.join('docs', 'modules.md'), 'utf8');
      const m = rawModules.match(/^#\s+(.+)$/m);
      if (m) typedocModulesTitle = m[1].trim();
    } catch (_) {}
    const renderGroupList = (groups) => groups.map(g => (
      `  <Accordion title="${g.group}">\n` +
      g.pages.map(p => `  - [${p.split('/').pop()}](/${p})`).join('\n') +
      `\n  </Accordion>`
    )).join('\n\n');

    const modulesContent = `---\n`+
`title: "${typedocModulesTitle}"\n`+
`sidebarTitle: "${typedocModulesTitle}"\n`+
`---\n\n`+
`<AccordionGroup>\n\n`+
`<Accordion title="Interfaces">\n\n`+
renderGroupList(interfaceGroups)+`\n\n`+
`</Accordion>\n\n`+
`<Accordion title="Classes">\n\n`+
renderGroupList(classGroups)+`\n\n`+
`</Accordion>\n\n`+
`</AccordionGroup>\n`;

    fs.writeFileSync(modulesOut, modulesContent);

    // Generate the TypeScript SDK navigation tab with requested structure
    const typescriptSdkNavigation = {
      tab: 'TypeScript SDK',
      hidden: true,
      pages: [
        'xdks/typescript/overview',
        'xdks/typescript/install',
        'xdks/typescript/authentication',
        'xdks/typescript/pagination',
        'xdks/typescript/streaming',
        {
          group: 'API Reference',
          pages: [
            'xdks/typescript/reference/modules',
            {
              group: 'Interfaces',
              pages: interfaceGroups
            },
            {
              group: 'Classes',
              pages: classGroups
            }
          ]
        }
      ]
    };
    
    // Also create a JSON file for easy copy-paste
    fs.writeFileSync(
      path.join(outputDir, 'typescript-sdk-navigation.json'), 
      JSON.stringify(typescriptSdkNavigation, null, 2)
    );
    
    console.log('‚úÖ TypeScript SDK documentation processed successfully!');
    console.log(`üìÅ Output directory: ${outputDir}/`);
    console.log(`üìä Processed ${processedFiles.length} files`);
    console.log('\nüöÄ Integration steps:');
    console.log('1. Copy the \'xdk/\' folder to your existing Mintlify site');
    console.log('2. Add the navigation structure from \'typescript-sdk-navigation.json\' to your mintlify.json');
    console.log('3. Push to your main branch to deploy');
    
  } catch (error) {
    console.error('‚ùå Error processing documentation:', error.message);
    process.exit(1);
  }
}

// Run the processing
processDocs();