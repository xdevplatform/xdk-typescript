// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * OAuth2 authentication utilities for the X API.
 */

import { CryptoUtils, generateCodeVerifier, generateCodeChallenge } from './crypto_utils.js';

/**
 * OAuth2 configuration options
 */
export interface OAuth2Config {
  /** Client ID */
  clientId: string;
  /** Client secret (optional for public clients) */
  clientSecret?: string;
  /** Redirect URI */
  redirectUri: string;
  /** Scopes to request */
  scope?: string[];
}

/**
 * OAuth2 token response
 */
export interface OAuth2Token {
  /** Access token */
  access_token: string;
  /** Token type */
  token_type: string;
  /** Expiration time in seconds */
  expires_in: number;
  /** Refresh token */
  refresh_token?: string;
  /** Scopes granted */
  scope?: string;
}

/**
 * OAuth2 authentication handler
 */
export class OAuth2 {
  private config: OAuth2Config;
  private token?: OAuth2Token;
  private tokenExpiresAt?: number;
  private codeVerifier?: string;
  private codeChallenge?: string;

  constructor(config: OAuth2Config) {
    this.config = {
      scope: ['tweet.read', 'users.read'],
      ...config
    };
  }

  /**
   * Get the authorization URL
   * @param state Optional state parameter for security
   * @returns Authorization URL
   */
  async getAuthorizationUrl(state?: string): Promise<string> {
    const params = new URLSearchParams({
      response_type: 'code',
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUri,
      scope: this.config.scope?.join(' ') || '',
      state: state || ''
    });

    // Add PKCE parameters if they've been set
    if (this.codeChallenge) {
      params.append('code_challenge', this.codeChallenge);
      params.append('code_challenge_method', 'S256');
    }

    return `https://x.com/i/oauth2/authorize?${params.toString()}`;
  }

  /**
   * Exchange authorization code for tokens
   * @param code Authorization code from callback
   * @param codeVerifier Optional code verifier for PKCE
   * @returns Promise with OAuth2 token
   */
  async exchangeCode(code: string, codeVerifier?: string): Promise<OAuth2Token> {
    const params = new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: this.config.redirectUri
    });

    // Add PKCE code verifier if provided
    if (codeVerifier) {
      params.append('code_verifier', codeVerifier);
    }

    // Prepare headers
    const headers: Record<string, string> = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    // Add Basic Auth header if client secret is provided (optional but recommended)
    if (this.config.clientSecret) {
      const credentials = this._base64Encode(`${this.config.clientId}:${this.config.clientSecret}`);
      headers['Authorization'] = `Basic ${credentials}`;
    } else {
      // Only add client_id to body if no client_secret (public client)
      params.append('client_id', this.config.clientId);
    }
    
    const response = await fetch('https://api.x.com/2/oauth2/token', {
      method: 'POST',
      headers,
      body: params.toString()
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => response.text());
      throw new Error(`HTTP error! status: ${response.status}, body: ${JSON.stringify(errorData)}`);
    }

    const data = await response.json();
    this.token = {
      access_token: data.access_token,
      token_type: data.token_type,
      expires_in: data.expires_in,
      refresh_token: data.refresh_token,
      scope: data.scope
    };

    return this.token;
  }

  /**
   * Refresh an access token using a refresh token
   * @param refreshToken The refresh token to use (uses stored token if not provided)
   * @returns Promise with new OAuth2 token
   */
  async refreshToken(refreshToken?: string): Promise<OAuth2Token> {
    const tokenToUse = refreshToken || this.token?.refresh_token;
    
    if (!tokenToUse) {
      throw new Error('No refresh token available. Please provide a refresh token or complete the OAuth2 flow first.');
    }

    const params = new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: tokenToUse
    });

    // Prepare headers
    const headers: Record<string, string> = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    // Add Basic Auth header if client secret is provided
    if (this.config.clientSecret) {
      const credentials = this._base64Encode(`${this.config.clientId}:${this.config.clientSecret}`);
      headers['Authorization'] = `Basic ${credentials}`;
    } else {
      // Only add client_id to body if no client_secret (public client)
      params.append('client_id', this.config.clientId);
    }

    const response = await fetch('https://api.x.com/2/oauth2/token', {
      method: 'POST',
      headers,
      body: params.toString()
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => response.text());
      throw new Error(`Failed to refresh token: ${response.status}, body: ${JSON.stringify(errorData)}`);
    }

    const data = await response.json();
    this.token = {
      access_token: data.access_token,
      token_type: data.token_type,
      expires_in: data.expires_in,
      refresh_token: data.refresh_token,
      scope: data.scope
    };
    // Track when the token expires
    if (data.expires_in) {
      this.tokenExpiresAt = Date.now() + (data.expires_in * 1000);
    }

    return this.token;
  }

  /**
   * Get the current token
   * @returns Current OAuth2 token if available
   */
  getToken(): OAuth2Token | undefined {
    return this.token;
  }

  /**
   * Set a token directly (useful for restoring from storage)
   * @param token The OAuth2 token to set
   * @param expiresAt Optional timestamp (ms) when the token expires
   */
  setToken(token: OAuth2Token, expiresAt?: number): void {
    this.token = token;
    if (expiresAt) {
      this.tokenExpiresAt = expiresAt;
    } else if (token.expires_in) {
      // If no explicit expiresAt but token has expires_in, calculate from now
      this.tokenExpiresAt = Date.now() + (token.expires_in * 1000);
    }
  }

  /**
   * Check if the current token is expired or about to expire
   * @param bufferSeconds Number of seconds before expiry to consider as "expiring" (default: 60)
   * @returns True if token is expired or missing
   */
  isTokenExpired(bufferSeconds: number = 60): boolean {
    if (!this.token) {
      return true;
    }
    // If we don't have timing info, assume not expired
    if (!this.tokenExpiresAt) {
      return false;
    }
    return Date.now() >= this.tokenExpiresAt - (bufferSeconds * 1000);
  }

  /**
   * Get the current code verifier (for PKCE)
   * @returns Current code verifier if available
   */
  getCodeVerifier(): string | undefined {
    return this.codeVerifier;
  }


  /**
   * Manually set PKCE parameters
   * @param codeVerifier The code verifier to use
   * @param codeChallenge Optional code challenge (will be generated if not provided)
   */
  async setPkceParameters(codeVerifier: string, codeChallenge?: string): Promise<void> {
    this.codeVerifier = codeVerifier;
    if (codeChallenge) {
      this.codeChallenge = codeChallenge;
    } else {
      this.codeChallenge = await generateCodeChallenge(codeVerifier);
    }
  }

  /**
   * Get the current code challenge (for PKCE)
   * @returns Current code challenge if available
   */
  getCodeChallenge(): string | undefined {
    return this.codeChallenge;
  }

  /**
   * Base64 encode a string (with fallback for environments without btoa)
   * @param str String to encode
   * @returns Base64 encoded string
   */
  private _base64Encode(str: string): string {
    if (typeof btoa !== 'undefined') {
      return btoa(str);
    } else if (typeof Buffer !== 'undefined') {
      // Node.js fallback
      return Buffer.from(str, 'utf8').toString('base64');
    } else {
      // Manual base64 encoding fallback
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      let result = '';
      let i = 0;
      while (i < str.length) {
        const a = str.charCodeAt(i++);
        const b = i < str.length ? str.charCodeAt(i++) : 0;
        const c = i < str.length ? str.charCodeAt(i++) : 0;
        const bitmap = (a << 16) | (b << 8) | c;
        result += chars.charAt((bitmap >> 18) & 63);
        result += chars.charAt((bitmap >> 12) & 63);
        result += i - 2 < str.length ? chars.charAt((bitmap >> 6) & 63) : '=';
        result += i - 1 < str.length ? chars.charAt(bitmap & 63) : '=';
      }
      return result;
    }
  }
} 