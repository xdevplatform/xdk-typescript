// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Stream client for the X API.
 *
 * This module provides a client for interacting with the streaming endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions } from '../client.js';
import { EventDrivenStream, StreamEvent } from './event_driven_stream.js';
import {

  SearchResponse,


  GetByIdResponse,

} from './models.js';

/**
 * Options for search method
 * 
 * @public
 */
export interface SearchStreamingOptions {
    
    
    /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase (e.g., nextToken) */
    nextToken?: any;
    
    
    
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: any;
    
    
    
    /** A comma separated list of Community fields to display. 
     * Also accepts: community.fields or proper camelCase (e.g., communityFields) */
    communityFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for getById method
 * 
 * @public
 */
export interface GetByIdStreamingOptions {
    
    
    /** A comma separated list of Community fields to display. 
     * Also accepts: community.fields or proper camelCase (e.g., communityFields) */
    communityFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


export class CommunitiesClient {
    private client: Client;

    constructor(client: Client) {
        this.client = client;
    }

    /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Only accepts: proper camelCase (tweetFields) and original API format (tweet.fields)
     */
    private _normalizeOptions<T extends Record<string, any>>(options: T, paramMappings: Record<string, string>): T {
        if (!options || typeof options !== 'object') {
            return options;
        }
        
        const normalized: any = { ...options };
        
        // For each parameter mapping (original -> proper camelCase)
        for (const [originalName, camelName] of Object.entries(paramMappings)) {
            // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
            if (originalName in normalized && !(camelName in normalized)) {
                normalized[camelName] = normalized[originalName];
                delete normalized[originalName];
            }
            // Also check for proper camelCase (e.g., 'tweetFields')
            // If it's already in proper camelCase, keep it (no conversion needed)
            // The camelName is already the proper camelCase format
        }
        
        return normalized as T;
    }











    /**
     * Search Communities
     * Retrieves a list of Communities matching the specified search query.
     * 
     * @returns Promise with the API response
     */
    async search(
        
        
        
        
        
        query: string,
        
        
        
        
        
        options: SearchStreamingOptions = {}
    ): Promise<SearchResponse> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('OAuth2UserToken');
        
        
        
        requiredAuthTypes.push('UserToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'search');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'next_token': 'nextToken',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'community.fields': 'communityFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            maxResults = undefined,
            
            
            
            nextToken = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            communityFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/communities/search';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        
        if (query !== undefined) {
            params.append('query', String(query));
        }
        
        
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        
        if (nextToken !== undefined) {
            
            params.append('next_token', String(nextToken));
            
        }
        
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        
        if (communityFields !== undefined && communityFields.length > 0) {
            
            params.append('community.fields', communityFields.join(','));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...headers,
            },
            signal: signal,
            
            ...requestOptions,
        };

        // Make the request
        return this.client.request<SearchResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }



    /**
     * Get Community by ID
     * Retrieves details of a specific Community by its ID.
     * 
     * @returns Promise with the API response
     */
    async getById(
        
        
        
        id: string,
        
        
        
        
        
        
        
        options: GetByIdStreamingOptions = {}
    ): Promise<GetByIdResponse> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        
        requiredAuthTypes.push('OAuth2UserToken');
        
        
        
        requiredAuthTypes.push('UserToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'getById');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'community.fields': 'communityFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            communityFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/communities/{id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (communityFields !== undefined && communityFields.length > 0) {
            
            params.append('community.fields', communityFields.join(','));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...headers,
            },
            signal: signal,
            
            ...requestOptions,
        };

        // Make the request
        return this.client.request<GetByIdResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }


}