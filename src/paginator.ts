// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Pagination utilities for the X API.
 *
 * This module provides comprehensive pagination support for the X API, including
 * automatic iteration, manual page control, and metadata access.
 *
 * @category Pagination
 */

/**
 * Paginated response interface
 *
 * Represents the structure of a paginated API response from the X API.
 *
 * @template T - The type of items in the response
 */
export interface PaginatedResponse<T> {
  /** Array of items in the current page */
  data: T[];
  /** Pagination metadata */
  meta?: {
    /** Number of results in the current page */
    result_count?: number;
    /** Token for fetching the next page */
    next_token?: string;
    /** Token for fetching the previous page */
    previous_token?: string;
  };
  /** Additional included objects (users, tweets, etc.) */
  includes?: Record<string, any>;
  /** Any errors in the response */
  errors?: Array<any>;
}

/**
 * X API paginator with rich functionality
 *
 * This class provides comprehensive pagination support for the X API, including:
 * - Automatic iteration with `for await...of` loops
 * - Manual page control with `fetchNext()` and `fetchPrevious()`
 * - Metadata access for pagination tokens and counts
 * - Error handling and rate limit detection
 * - Support for both forward and backward pagination
 *
 * @template T - The type of items being paginated
 *
 * @example
 * ```typescript
 * // Automatic iteration
 * const followers = await client.users.getFollowers('783214');
 * for await (const follower of followers) {
 *   console.log(follower.username);
 * }
 *
 * // Manual control
 * const followers = await client.users.getFollowers('783214');
 * await followers.fetchNext();
 * console.log(followers.items.length); // Number of followers
 * console.log(followers.meta.next_token); // Next page token
 *
 * // Check status
 * if (!followers.done) {
 *   await followers.fetchNext();
 * }
 * ```
 *
 * @category Pagination
 */
export class Paginator<T> implements AsyncIterable<T> {
  private fetchPage: (token?: string) => Promise<PaginatedResponse<T>>;
  private currentToken?: string;
  private previousToken?: string;
  private hasMore: boolean = true;
  private isDone: boolean = false;
  private allItems: T[] = [];
  private currentMeta?: any;
  private currentIncludes?: Record<string, any>;
  private currentErrors?: Array<any>;
  private rateLimitHit: boolean = false;

  /**
   * Creates a new paginator instance
   *
   * @param fetchPage - Function that fetches a page of data given a pagination token
   */
  constructor(fetchPage: (token?: string) => Promise<PaginatedResponse<T>>) {
    this.fetchPage = fetchPage;
  }

  /**
   * Get all fetched items
   */
  get items(): T[] {
    return [...this.allItems];
  }

  /**
   * Get current pagination metadata
   */
  get meta(): any {
    return this.currentMeta;
  }

  /**
   * Get current includes data
   */
  get includes(): Record<string, any> | undefined {
    return this.currentIncludes;
  }

  /**
   * Get current errors
   */
  get errors(): Array<any> | undefined {
    return this.currentErrors;
  }

  /**
   * Check if pagination is done
   */
  get done(): boolean {
    return this.isDone || this.rateLimitHit;
  }

  /**
   * Check if rate limit was hit
   */
  get rateLimited(): boolean {
    return this.rateLimitHit;
  }

  /**
   * Fetch the next page and add items to current instance
   *
   * This method fetches the next page of data and appends the items to the
   * current paginator instance. It updates the pagination state and metadata.
   *
   * @example
   * ```typescript
   * const followers = await client.users.getFollowers('783214');
   * await followers.fetchNext(); // Fetch first page
   * console.log(followers.items.length); // Number of followers
   *
   * if (!followers.done) {
   *   await followers.fetchNext(); // Fetch second page
   *   console.log(followers.items.length); // Total followers across pages
   * }
   * ```
   *
   * @throws {Error} When the API request fails
   */
  async fetchNext(): Promise<void> {
    if (this.done) {
      return;
    }

    try {
      const response = await this.fetchPage(this.currentToken);

      // Update tokens
      this.previousToken = this.currentToken;
      this.currentToken = response.meta?.next_token;

      // Update state
      this.hasMore = !!this.currentToken;
      this.isDone = !this.hasMore;

      // Add new items to collection
      if (response.data) {
        this.allItems.push(...response.data);
      }

      // Update metadata
      this.currentMeta = response.meta;
      this.currentIncludes = response.includes;
      this.currentErrors = response.errors;
    } catch (error: any) {
      // Check if it's a rate limit error
      if (error.status === 429 || error.message?.includes('rate limit')) {
        this.rateLimitHit = true;
      }
      throw error;
    }
  }

  /**
   * Get next page as a new instance
   *
   * This method creates a new paginator instance that starts from the next page,
   * without affecting the current paginator's state.
   *
   * @example
   * ```typescript
   * const followers = await client.users.getFollowers('783214');
   * await followers.fetchNext(); // Fetch first page
   *
   * if (!followers.done) {
   *   const nextPage = await followers.next(); // Get next page as new instance
   *   console.log(followers.items.length); // Still first page
   *   console.log(nextPage.items.length); // Second page
   * }
   * ```
   *
   * @returns New paginator instance for the next page
   */
  async next(): Promise<Paginator<T>> {
    if (this.done) {
      return new Paginator(this.fetchPage);
    }

    const nextPaginator = new Paginator(this.fetchPage);
    nextPaginator.currentToken = this.currentToken;
    await nextPaginator.fetchNext();
    return nextPaginator;
  }

  /**
   * Fetch previous page (if supported)
   */
  async fetchPrevious(): Promise<void> {
    if (!this.previousToken) {
      return;
    }

    try {
      const response = await this.fetchPage(this.previousToken);

      // Update tokens
      this.currentToken = this.previousToken;
      this.previousToken = response.meta?.previous_token;

      // Update state
      this.hasMore = !!this.currentToken;
      this.isDone = !this.hasMore;

      // Replace items with previous page items
      this.allItems = response.data || [];

      // Update metadata
      this.currentMeta = response.meta;
      this.currentIncludes = response.includes;
      this.currentErrors = response.errors;
    } catch (error: any) {
      if (error.status === 429 || error.message?.includes('rate limit')) {
        this.rateLimitHit = true;
      }
      throw error;
    }
  }

  /**
   * Get previous page as a new instance
   */
  async previous(): Promise<Paginator<T>> {
    if (!this.previousToken) {
      return new Paginator(this.fetchPage);
    }

    const prevPaginator = new Paginator(this.fetchPage);
    prevPaginator.currentToken = this.previousToken;
    await prevPaginator.fetchNext();
    return prevPaginator;
  }

  /**
   * Fetch up to a specified number of additional items
   */
  async fetchLast(count: number): Promise<void> {
    let fetched = 0;

    while (!this.done && fetched < count) {
      const beforeCount = this.allItems.length;
      await this.fetchNext();
      const afterCount = this.allItems.length;
      fetched += afterCount - beforeCount;
    }
  }

  /**
   * Reset paginator to initial state
   */
  reset(): void {
    this.currentToken = undefined;
    this.previousToken = undefined;
    this.hasMore = true;
    this.isDone = false;
    this.allItems = [];
    this.currentMeta = undefined;
    this.currentIncludes = undefined;
    this.currentErrors = undefined;
    this.rateLimitHit = false;
  }

  /**
   * Iterator for all fetched items
   */
  *[Symbol.iterator](): Iterator<T> {
    for (const item of this.allItems) {
      yield item;
    }
  }

  /**
   * Async iterator that fetches pages automatically
   */
  async *[Symbol.asyncIterator](): AsyncIterator<T> {
    let lastYieldedIndex = 0;

    // First, yield all currently fetched items
    for (let i = lastYieldedIndex; i < this.allItems.length; i++) {
      yield this.allItems[i];
    }
    lastYieldedIndex = this.allItems.length;

    // Then continue fetching and yielding new items
    while (!this.done) {
      await this.fetchNext();

      // Yield only new items since last iteration
      for (let i = lastYieldedIndex; i < this.allItems.length; i++) {
        yield this.allItems[i];
      }
      lastYieldedIndex = this.allItems.length;
    }
  }
}

/**
 * Specialized paginators for different data types
 */

/**
 * Paginator for posts
 */
export class PostPaginator extends Paginator<any> {
  get posts(): any[] {
    return this.items;
  }
}

/**
 * Paginator for users
 */
export class UserPaginator extends Paginator<any> {
  get users(): any[] {
    return this.items;
  }
}

/**
 * Paginator for events (like DM events)
 */
export class EventPaginator extends Paginator<any> {
  get events(): any[] {
    return this.items;
  }
}
