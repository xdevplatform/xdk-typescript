// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Environment-agnostic cryptographic utilities for the X API SDK.
 * Provides HMAC-SHA1 implementation that works in Node.js, browser, and React Native environments.
 */

// Environment detection
const isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';
const isNode = !isReactNative && typeof process !== 'undefined' && process.versions && process.versions.node;
const isBrowser = !isReactNative && !isNode && typeof window !== 'undefined';

/**
 * HMAC-SHA1 implementation that works in Node.js, browser, and React Native environments
 */
export class CryptoUtils {
  /**
   * Generate HMAC-SHA1 signature
   * @param key Signing key
   * @param message Message to sign
   * @returns Base64 encoded signature
   */
  static async hmacSha1(key: string, message: string): Promise<string> {
    // For React Native, prefer Web Crypto API (requires react-native-get-random-values polyfill)
    // or fall back to polyfill
    if (isReactNative) {
      // Try Web Crypto API first (available if user installed crypto polyfills)
      if (typeof crypto !== 'undefined' && crypto.subtle) {
        try {
          return await this._webCryptoHmacSha1(key, message);
        } catch (error) {
          // Fall back to polyfill
        }
      }
      // Use polyfill for React Native
      return this._polyfillHmacSha1(key, message);
    }

    // Try to use native Node.js crypto first
    if (isNode) {
      try {
        return await this._nodeHmacSha1(key, message);
      } catch (error) {
        // Fall back to Web Crypto API or polyfill
        console.warn('Node.js crypto failed, falling back:', error);
      }
    }

    // Try Web Crypto API (modern browsers and some environments)
    if (typeof crypto !== 'undefined' && crypto.subtle) {
      try {
        return await this._webCryptoHmacSha1(key, message);
      } catch (error) {
        // Fall back to polyfill
        console.warn('Web Crypto API failed, falling back:', error);
      }
    }

    // Fall back to polyfill implementation
    return this._polyfillHmacSha1(key, message);
  }

  /**
   * Node.js native HMAC-SHA1 implementation
   */
  private static async _nodeHmacSha1(key: string, message: string): Promise<string> {
    // Dynamic import for Node.js crypto module (ES module compatible)
    const crypto = await import('crypto');
    const hmac = crypto.createHmac('sha1', key);
    hmac.update(message);
    return hmac.digest('base64');
  }

  /**
   * Web Crypto API HMAC-SHA1 implementation
   */
  private static async _webCryptoHmacSha1(key: string, message: string): Promise<string> {
    // Convert string key to ArrayBuffer
    const keyBuffer = this._stringToArrayBuffer(key);
    const messageBuffer = this._stringToArrayBuffer(message);

    // Import the key
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      { name: 'HMAC', hash: 'SHA-1' },
      false,
      ['sign']
    );

    // Sign the message
    const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageBuffer);

    // Convert to base64
    return this._arrayBufferToBase64(signature);
  }

  /**
   * Polyfill HMAC-SHA1 implementation using pure JavaScript
   * This is a fallback that works everywhere including React Native
   */
  private static _polyfillHmacSha1(key: string, message: string): string {
    // Pure JavaScript HMAC-SHA1 implementation
    const sha1 = this._sha1;
    const blockSize = 64;
    
    // Convert key to bytes
    let keyBytes = this._stringToBytes(key);
    
    // If key is longer than block size, hash it
    if (keyBytes.length > blockSize) {
      keyBytes = sha1(keyBytes);
    }
    
    // Pad key to block size
    while (keyBytes.length < blockSize) {
      keyBytes.push(0);
    }
    
    // Create inner and outer padding
    const innerPad: number[] = [];
    const outerPad: number[] = [];
    for (let i = 0; i < blockSize; i++) {
      innerPad.push(keyBytes[i] ^ 0x36);
      outerPad.push(keyBytes[i] ^ 0x5c);
    }
    
    // Inner hash: SHA1(innerPad + message)
    const messageBytes = this._stringToBytes(message);
    const innerHash = sha1(innerPad.concat(messageBytes));
    
    // Outer hash: SHA1(outerPad + innerHash)
    const hmacBytes = sha1(outerPad.concat(innerHash));
    
    // Convert to base64
    let binary = '';
    for (let i = 0; i < hmacBytes.length; i++) {
      binary += String.fromCharCode(hmacBytes[i]);
    }
    return btoa(binary);
  }

  /**
   * Pure JavaScript SHA-1 implementation
   */
  private static _sha1(message: number[]): number[] {
    // Pre-processing
    const msgLen = message.length;
    const bitLen = msgLen * 8;
    
    // Append bit '1' to message
    message.push(0x80);
    
    // Append zeros until message length ≡ 448 (mod 512)
    while ((message.length % 64) !== 56) {
      message.push(0);
    }
    
    // Append original length in bits as 64-bit big-endian
    for (let i = 56; i >= 0; i -= 8) {
      message.push((bitLen >>> i) & 0xff);
    }
    
    // Initialize hash values
    let h0 = 0x67452301;
    let h1 = 0xEFCDAB89;
    let h2 = 0x98BADCFE;
    let h3 = 0x10325476;
    let h4 = 0xC3D2E1F0;
    
    // Process each 512-bit chunk
    for (let i = 0; i < message.length; i += 64) {
      const w: number[] = [];
      
      // Break chunk into sixteen 32-bit big-endian words
      for (let j = 0; j < 16; j++) {
        w[j] = (message[i + j * 4] << 24) |
               (message[i + j * 4 + 1] << 16) |
               (message[i + j * 4 + 2] << 8) |
               (message[i + j * 4 + 3]);
      }
      
      // Extend sixteen 32-bit words into eighty 32-bit words
      for (let j = 16; j < 80; j++) {
        const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
        w[j] = (n << 1) | (n >>> 31);
      }
      
      // Initialize working variables
      let a = h0, b = h1, c = h2, d = h3, e = h4;
      
      // Main loop
      for (let j = 0; j < 80; j++) {
        let f: number, k: number;
        if (j < 20) {
          f = (b & c) | ((~b) & d);
          k = 0x5A827999;
        } else if (j < 40) {
          f = b ^ c ^ d;
          k = 0x6ED9EBA1;
        } else if (j < 60) {
          f = (b & c) | (b & d) | (c & d);
          k = 0x8F1BBCDC;
        } else {
          f = b ^ c ^ d;
          k = 0xCA62C1D6;
        }
        
        const temp = (((a << 5) | (a >>> 27)) + f + e + k + w[j]) >>> 0;
        e = d;
        d = c;
        c = ((b << 30) | (b >>> 2)) >>> 0;
        b = a;
        a = temp;
      }
      
      // Add chunk's hash to result
      h0 = (h0 + a) >>> 0;
      h1 = (h1 + b) >>> 0;
      h2 = (h2 + c) >>> 0;
      h3 = (h3 + d) >>> 0;
      h4 = (h4 + e) >>> 0;
    }
    
    // Produce the final hash value (big-endian)
    const hash: number[] = [];
    for (const h of [h0, h1, h2, h3, h4]) {
      hash.push((h >>> 24) & 0xff);
      hash.push((h >>> 16) & 0xff);
      hash.push((h >>> 8) & 0xff);
      hash.push(h & 0xff);
    }
    return hash;
  }

  /**
   * Convert string to byte array
   */
  private static _stringToBytes(str: string): number[] {
    const bytes: number[] = [];
    for (let i = 0; i < str.length; i++) {
      bytes.push(str.charCodeAt(i) & 0xff);
    }
    return bytes;
  }

  /**
   * Convert string to ArrayBuffer
   */
  private static _stringToArrayBuffer(str: string): ArrayBuffer {
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < str.length; i++) {
      view[i] = str.charCodeAt(i);
    }
    return buffer;
  }

  /**
   * Convert ArrayBuffer to base64 string
   */
  private static _arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  /**
   * Generate a random nonce for OAuth
   * @param length Length of the nonce
   * @returns Random nonce string
   */
  static generateNonce(length: number = 32): string {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      // Use crypto.getRandomValues if available
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    } else {
      // Fallback to Math.random (less secure but functional)
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      return result;
    }
  }

  /**
   * Generate timestamp for OAuth
   * @returns Unix timestamp as string
   */
  static generateTimestamp(): string {
    return Math.floor(Date.now() / 1000).toString();
  }

  /**
   * Generate a cryptographically secure random string for PKCE code verifier
   * @param length Length of the code verifier (43-128 characters recommended)
   * @returns Random code verifier string
   */
  static generateCodeVerifier(length: number = 128): string {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      // Use crypto.getRandomValues if available
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      // Convert to base64url encoding (RFC 7636)
      return this._base64UrlEncode(array);
    } else {
      // Fallback to Math.random (less secure but functional)
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      return result;
    }
  }

  /**
   * Generate PKCE code challenge from code verifier
   * @param codeVerifier The code verifier string
   * @returns Base64url encoded SHA256 hash of the code verifier
   */
  static async generateCodeChallenge(codeVerifier: string): Promise<string> {
    // For React Native, prefer Web Crypto API or fall back to polyfill
    if (isReactNative) {
      if (typeof crypto !== 'undefined' && crypto.subtle) {
        try {
          return await this._webCryptoSha256(codeVerifier);
        } catch (error) {
          // Fall back to polyfill
        }
      }
      return this._polyfillSha256(codeVerifier);
    }

    // Try to use native Node.js crypto first
    if (isNode) {
      try {
        return await this._nodeSha256(codeVerifier);
      } catch (error) {
        console.warn('Node.js crypto failed for SHA256, falling back:', error);
      }
    }

    // Try Web Crypto API (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.subtle) {
      try {
        return await this._webCryptoSha256(codeVerifier);
      } catch (error) {
        console.warn('Web Crypto API failed for SHA256, falling back:', error);
      }
    }

    // Fall back to polyfill implementation
    return this._polyfillSha256(codeVerifier);
  }

  /**
   * Node.js native SHA256 implementation for PKCE
   */
  private static async _nodeSha256(message: string): Promise<string> {
    const crypto = await import('crypto');
    const hash = crypto.createHash('sha256');
    hash.update(message);
    const digest = hash.digest();
    return this._base64UrlEncode(digest);
  }

  /**
   * Web Crypto API SHA256 implementation for PKCE
   */
  private static async _webCryptoSha256(message: string): Promise<string> {
    const messageBuffer = this._stringToArrayBuffer(message);
    const hashBuffer = await crypto.subtle.digest('SHA-256', messageBuffer);
    return this._base64UrlEncode(hashBuffer);
  }

  /**
   * Polyfill SHA256 implementation for PKCE
   * Pure JavaScript implementation that works in React Native and other environments
   */
  private static _polyfillSha256(message: string): string {
    // Pure JavaScript SHA-256 implementation
    const msgBytes = this._stringToBytes(message);
    const hashBytes = this._sha256(msgBytes);
    return this._base64UrlEncode(new Uint8Array(hashBytes));
  }

  /**
   * Pure JavaScript SHA-256 implementation
   */
  private static _sha256(message: number[]): number[] {
    // SHA-256 constants
    const K = [
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];

    // Pre-processing
    const msgLen = message.length;
    const bitLen = msgLen * 8;
    
    // Append bit '1' to message
    message.push(0x80);
    
    // Append zeros until message length ≡ 448 (mod 512)
    while ((message.length % 64) !== 56) {
      message.push(0);
    }
    
    // Append original length in bits as 64-bit big-endian
    // Note: JavaScript bitwise operations work on 32 bits, so we handle this carefully
    message.push(0, 0, 0, 0); // High 32 bits (assuming message < 2^32 bits)
    message.push((bitLen >>> 24) & 0xff);
    message.push((bitLen >>> 16) & 0xff);
    message.push((bitLen >>> 8) & 0xff);
    message.push(bitLen & 0xff);
    
    // Initialize hash values
    let h0 = 0x6a09e667;
    let h1 = 0xbb67ae85;
    let h2 = 0x3c6ef372;
    let h3 = 0xa54ff53a;
    let h4 = 0x510e527f;
    let h5 = 0x9b05688c;
    let h6 = 0x1f83d9ab;
    let h7 = 0x5be0cd19;
    
    // Helper functions
    const rotr = (n: number, x: number) => ((x >>> n) | (x << (32 - n))) >>> 0;
    const ch = (x: number, y: number, z: number) => ((x & y) ^ ((~x) & z)) >>> 0;
    const maj = (x: number, y: number, z: number) => ((x & y) ^ (x & z) ^ (y & z)) >>> 0;
    const sigma0 = (x: number) => (rotr(2, x) ^ rotr(13, x) ^ rotr(22, x)) >>> 0;
    const sigma1 = (x: number) => (rotr(6, x) ^ rotr(11, x) ^ rotr(25, x)) >>> 0;
    const gamma0 = (x: number) => (rotr(7, x) ^ rotr(18, x) ^ (x >>> 3)) >>> 0;
    const gamma1 = (x: number) => (rotr(17, x) ^ rotr(19, x) ^ (x >>> 10)) >>> 0;
    
    // Process each 512-bit chunk
    for (let i = 0; i < message.length; i += 64) {
      const w: number[] = [];
      
      // Break chunk into sixteen 32-bit big-endian words
      for (let j = 0; j < 16; j++) {
        w[j] = ((message[i + j * 4] << 24) |
                (message[i + j * 4 + 1] << 16) |
                (message[i + j * 4 + 2] << 8) |
                (message[i + j * 4 + 3])) >>> 0;
      }
      
      // Extend sixteen 32-bit words into sixty-four 32-bit words
      for (let j = 16; j < 64; j++) {
        w[j] = (gamma1(w[j - 2]) + w[j - 7] + gamma0(w[j - 15]) + w[j - 16]) >>> 0;
      }
      
      // Initialize working variables
      let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;
      
      // Main loop
      for (let j = 0; j < 64; j++) {
        const t1 = (h + sigma1(e) + ch(e, f, g) + K[j] + w[j]) >>> 0;
        const t2 = (sigma0(a) + maj(a, b, c)) >>> 0;
        h = g;
        g = f;
        f = e;
        e = (d + t1) >>> 0;
        d = c;
        c = b;
        b = a;
        a = (t1 + t2) >>> 0;
      }
      
      // Add chunk's hash to result
      h0 = (h0 + a) >>> 0;
      h1 = (h1 + b) >>> 0;
      h2 = (h2 + c) >>> 0;
      h3 = (h3 + d) >>> 0;
      h4 = (h4 + e) >>> 0;
      h5 = (h5 + f) >>> 0;
      h6 = (h6 + g) >>> 0;
      h7 = (h7 + h) >>> 0;
    }
    
    // Produce the final hash value (big-endian)
    const hash: number[] = [];
    for (const hVal of [h0, h1, h2, h3, h4, h5, h6, h7]) {
      hash.push((hVal >>> 24) & 0xff);
      hash.push((hVal >>> 16) & 0xff);
      hash.push((hVal >>> 8) & 0xff);
      hash.push(hVal & 0xff);
    }
    return hash;
  }

  /**
   * Convert ArrayBuffer or Uint8Array to base64url encoding (RFC 7636)
   */
  private static _base64UrlEncode(buffer: ArrayBuffer | Uint8Array): string {
    const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    // Convert to base64url: replace + with -, / with _, and remove padding =
    return btoa(binary)
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }
}

/**
 * Convenience function for HMAC-SHA1
 * @param key Signing key
 * @param message Message to sign
 * @returns Promise that resolves to base64 encoded signature
 */
export async function hmacSha1(key: string, message: string): Promise<string> {
  return CryptoUtils.hmacSha1(key, message);
}

/**
 * Convenience function for generating nonce
 * @param length Length of the nonce
 * @returns Random nonce string
 */
export function generateNonce(length: number = 32): string {
  return CryptoUtils.generateNonce(length);
}

/**
 * Convenience function for generating timestamp
 * @returns Unix timestamp as string
 */
export function generateTimestamp(): string {
  return CryptoUtils.generateTimestamp();
}

/**
 * Convenience function for generating PKCE code verifier
 * @param length Length of the code verifier
 * @returns Random code verifier string
 */
export function generateCodeVerifier(length: number = 128): string {
  return CryptoUtils.generateCodeVerifier(length);
}

/**
 * Convenience function for generating PKCE code challenge
 * @param codeVerifier The code verifier string
 * @returns Promise that resolves to base64url encoded SHA256 hash
 */
export async function generateCodeChallenge(codeVerifier: string): Promise<string> {
  return CryptoUtils.generateCodeChallenge(codeVerifier);
} 