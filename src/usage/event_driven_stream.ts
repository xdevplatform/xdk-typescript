// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Event-driven streaming utilities for the X API.
 *
 * This module provides event-driven streaming interfaces that are more user-friendly
 * than manual ReadableStream management.
 */

// Event types for the stream (using string literals for simplicity)
// Based on actual Twitter API behavior from documentation
export const StreamEvent = {
  Data: 'data', // When JSON data arrives
  KeepAlive: 'keepAlive', // 20-second heartbeat (newline character)
  Error: 'error', // HTTP errors, ConnectionException, operational-disconnect
  Close: 'close', // When stream ends
};

// Event data types
export interface StreamDataEvent {
  data: any;
  includes?: any;
  matching_rules?: any[];
}

export interface StreamErrorEvent {
  error: Error;
  // Additional error details from the API response
  code?: string;
  status?: number;
}

/**
 * Event-driven stream class for handling streaming data from the X API.
 *
 * This class provides an event-driven interface for working with streaming endpoints,
 * allowing you to listen to 'data', 'keepAlive', 'error', and 'close' events.
 *
 * @public
 */
export class EventDrivenStream {
  private webStream: ReadableStream<Uint8Array> | null = null;
  private reader: ReadableStreamDefaultReader<Uint8Array> | null = null;
  private decoder: TextDecoder;
  private isConnected: boolean = false;
  private isClosed: boolean = false;
  private buffer: string = '';
  private eventListeners: Map<string, Function[]> = new Map();
  private autoReconnect: boolean = false;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelay: number = 1000;

  constructor() {
    this.decoder = new TextDecoder();
    this.setupEventListeners();
  }

  /**
   * Initialize the stream with a Web ReadableStream
   */
  async connect(webStream: ReadableStream<Uint8Array>): Promise<void> {
    if (this.isConnected) {
      throw new Error('Stream is already connected');
    }

    this.webStream = webStream;
    this.isConnected = true;
    this.isClosed = false;
    this.reconnectAttempts = 0;

    this.emit(StreamEvent.Data, { message: 'Stream connected' });
    this.startReading(); // Don't await this - it runs in the background
  }

  /**
   * Start reading from the stream
   */
  private async startReading(): Promise<void> {
    if (!this.webStream || !this.isConnected) {
      return;
    }

    this.reader = this.webStream.getReader();

    try {
      while (this.isConnected && !this.isClosed) {
        const { done, value } = await this.reader.read();

        if (done) {
          this.handleConnectionClosed();
          break;
        }

        if (value) {
          await this.processChunk(value);
        }
      }
    } catch (error) {
      this.handleConnectionError(error as Error);
    } finally {
      this.cleanup();
    }
  }

  /**
   * Process incoming data chunks
   */
  private async processChunk(value: Uint8Array): Promise<void> {
    const chunk = this.decoder.decode(value, { stream: true });
    this.buffer += chunk;

    // Process complete lines (ending with newline)
    let boundary;
    while ((boundary = this.buffer.indexOf('\n')) !== -1) {
      const line = this.buffer.substring(0, boundary);
      this.buffer = this.buffer.substring(boundary + 1);

      if (line.trim()) {
        try {
          const data = JSON.parse(line);

          // Check if it's a keep-alive signal (20-second heartbeat)
          if (this.isKeepAlive(data)) {
            this.emit(StreamEvent.KeepAlive, { data });
            continue;
          }

          // Emit data event for actual content
          this.emit(StreamEvent.Data, data);
        } catch (parseError) {
          // Skip invalid JSON lines - these are usually incomplete chunks
          console.warn('Skipping invalid JSON:', line.substring(0, 100));
        }
      }
    }
  }

  /**
   * Check if data is a keep-alive signal (20-second heartbeat)
   * Twitter sends newline characters every 20 seconds to prevent timeouts
   */
  private isKeepAlive(data: any): boolean {
    // Twitter sends empty objects or just newline characters as keep-alive
    return !data.data && !data.includes && !data.matching_rules && !data.errors;
  }

  /**
   * Handle connection errors
   */
  private handleConnectionError(error: Error): void {
    this.isConnected = false;

    // Emit the error as-is (API returns the actual error details)
    this.emit(StreamEvent.Error, { error });

    if (
      this.autoReconnect &&
      this.reconnectAttempts < this.maxReconnectAttempts
    ) {
      this.attemptReconnect();
    }
  }

  /**
   * Handle connection closed
   */
  private handleConnectionClosed(): void {
    this.isConnected = false;
    this.emit(StreamEvent.Close, { message: 'Connection closed' });
  }

  /**
   * Attempt to reconnect
   */
  private async attemptReconnect(): Promise<void> {
    this.reconnectAttempts++;
    this.emit(StreamEvent.Data, {
      message: `Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`,
    });

    // Wait before reconnecting
    await new Promise((resolve) =>
      setTimeout(resolve, this.reconnectDelay * this.reconnectAttempts)
    );

    try {
      // This would need to be implemented based on how you get a new stream
      // For now, we'll just emit the events
      this.emit(StreamEvent.Error, {
        error: new Error('Reconnect not implemented in this example'),
      });
    } catch (error) {
      this.emit(StreamEvent.Error, { error: error as Error });
    }
  }

  /**
   * Clean up resources
   */
  private cleanup(): void {
    if (this.reader) {
      try {
        // Try to release the lock - it will throw if already released
        this.reader.releaseLock();
      } catch (error) {
        // Ignore errors when releasing the lock (already released)
        console.debug('Reader lock already released or error:', error);
      }
      this.reader = null;
    }
    this.buffer = '';
  }

  /**
   * Close the stream
   */
  close(): void {
    this.isClosed = true;
    this.isConnected = false;
    this.cleanup();
    this.emit(StreamEvent.Close, { message: 'Stream closed by user' });
  }

  /**
   * Add event listener
   */
  on(event: string, listener: Function): this {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, []);
    }
    this.eventListeners.get(event)!.push(listener);
    return this;
  }

  /**
   * Remove event listener
   */
  off(event: string, listener: Function): this {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    return this;
  }

  /**
   * Emit event to listeners
   */
  private emit(event: string, data: any): void {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.forEach((listener) => {
        try {
          listener(data);
        } catch (error) {
          console.error(`Error in ${event} listener:`, error);
        }
      });
    }
  }

  /**
   * Setup default event listeners
   */
  private setupEventListeners(): void {
    // Default error handling
    this.on(StreamEvent.Error, (eventData: StreamErrorEvent) => {
      console.error('Stream error:', eventData.error);
    });
  }

  /**
   * Enable/disable auto-reconnect
   */
  set autoReconnectEnabled(enabled: boolean) {
    this.autoReconnect = enabled;
  }

  get autoReconnectEnabled(): boolean {
    return this.autoReconnect;
  }

  /**
   * Set max reconnect attempts
   */
  set maxReconnectAttemptsCount(count: number) {
    this.maxReconnectAttempts = count;
  }

  get maxReconnectAttemptsCount(): number {
    return this.maxReconnectAttempts;
  }

  /**
   * Async iterator for tweets
   */
  async *[Symbol.asyncIterator](): AsyncGenerator<
    StreamDataEvent,
    void,
    unknown
  > {
    const dataQueue: StreamDataEvent[] = [];
    let isComplete = false;
    let hasError = false;
    let error: Error | null = null;

    // Set up listeners
    const dataListener = (eventData: any) => {
      dataQueue.push(eventData);
    };

    const errorListener = (eventData: StreamErrorEvent) => {
      hasError = true;
      error = eventData.error;
    };

    const closeListener = () => {
      isComplete = true;
    };

    this.on(StreamEvent.Data, dataListener);
    this.on(StreamEvent.Error, errorListener);
    this.on(StreamEvent.Close, closeListener);

    try {
      while (!isComplete && !hasError) {
        if (dataQueue.length > 0) {
          yield dataQueue.shift()!;
        } else {
          // Wait a bit for more data
          await new Promise((resolve) => setTimeout(resolve, 10));
        }
      }

      if (hasError && error) {
        throw error;
      }
    } finally {
      // Clean up listeners
      this.off(StreamEvent.Data, dataListener);
      this.off(StreamEvent.Error, errorListener);
      this.off(StreamEvent.Close, closeListener);
    }
  }
}
