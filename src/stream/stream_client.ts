// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Stream client for the X API.
 *
 * This module provides a client for interacting with the streaming endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions } from '../client.js';
import { EventDrivenStream, StreamEvent } from './event_driven_stream.js';
import {

  PostsSample10Response,


  PostsComplianceResponse,


  PostsFirehosePtResponse,


  GetRulesResponse,


  UpdateRulesResponse,


  LikesFirehoseResponse,


  PostsSampleResponse,


  GetRuleCountsResponse,


  PostsFirehoseKoResponse,


  LikesSample10Response,


  PostsResponse,


  LikesComplianceResponse,


  UsersComplianceResponse,


  LabelsComplianceResponse,


  PostsFirehoseJaResponse,


  PostsFirehoseEnResponse,


  PostsFirehoseResponse,

} from './models.js';

/**
 * Options for postsSample10 method
 * 
 * @public
 */
export interface PostsSample10StreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsCompliance method
 * 
 * @public
 */
export interface PostsComplianceStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Post Compliance events will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Post Compliance events will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsFirehosePt method
 * 
 * @public
 */
export interface PostsFirehosePtStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for getRules method
 * 
 * @public
 */
export interface GetRulesStreamingOptions {
    
    
    /** A comma-separated list of Rule IDs. 
     * Also accepts: ids or proper camelCase (e.g., ids) */
    ids?: Array<any>;
    
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This value is populated by passing the 'next_token' returned in a request to paginate through results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for updateRules method
 * 
 * @public
 */
export interface UpdateRulesStreamingOptions {
    
    
    /** Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. 
     * Also accepts: dry_run or proper camelCase (e.g., dryRun) */
    dryRun?: boolean;
    
    
    
    /** Delete All can be used to delete all of the rules associated this client app, it should be specified with no other parameters. Once deleted, rules cannot be recovered. 
     * Also accepts: delete_all or proper camelCase (e.g., deleteAll) */
    deleteAll?: boolean;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for likesFirehose method
 * 
 * @public
 */
export interface LikesFirehoseStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Likes will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of LikeWithTweetAuthor fields to display. 
     * Also accepts: like_with_tweet_author.fields or proper camelCase (e.g., likeWithTweetAuthorFields) */
    likeWithTweetAuthorFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsSample method
 * 
 * @public
 */
export interface PostsSampleStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for getRuleCounts method
 * 
 * @public
 */
export interface GetRuleCountsStreamingOptions {
    
    
    /** A comma separated list of RulesCount fields to display. 
     * Also accepts: rules_count.fields or proper camelCase (e.g., rulesCountFields) */
    rulesCountFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsFirehoseKo method
 * 
 * @public
 */
export interface PostsFirehoseKoStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for likesSample10 method
 * 
 * @public
 */
export interface LikesSample10StreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Likes will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of LikeWithTweetAuthor fields to display. 
     * Also accepts: like_with_tweet_author.fields or proper camelCase (e.g., likeWithTweetAuthorFields) */
    likeWithTweetAuthorFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for posts method
 * 
 * @public
 */
export interface PostsStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for likesCompliance method
 * 
 * @public
 */
export interface LikesComplianceStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Likes Compliance events will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Likes Compliance events will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for usersCompliance method
 * 
 * @public
 */
export interface UsersComplianceStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for labelsCompliance method
 * 
 * @public
 */
export interface LabelsComplianceStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Post labels will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Post labels will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsFirehoseJa method
 * 
 * @public
 */
export interface PostsFirehoseJaStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsFirehoseEn method
 * 
 * @public
 */
export interface PostsFirehoseEnStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}
/**
 * Options for postsFirehose method
 * 
 * @public
 */
export interface PostsFirehoseStreamingOptions {
    
    
    /** The number of minutes of backfill requested. 
     * Also accepts: backfill_minutes or proper camelCase (e.g., backfillMinutes) */
    backfillMinutes?: number;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Posts will be provided. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Additional headers */
    headers?: Record<string, string>;
    /** AbortSignal for cancelling the request */
    signal?: AbortSignal;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


export class StreamClient {
    private client: Client;

    constructor(client: Client) {
        this.client = client;
    }

    /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Only accepts: proper camelCase (tweetFields) and original API format (tweet.fields)
     */
    private _normalizeOptions<T extends Record<string, any>>(options: T, paramMappings: Record<string, string>): T {
        if (!options || typeof options !== 'object') {
            return options;
        }
        
        const normalized: any = { ...options };
        
        // For each parameter mapping (original -> proper camelCase)
        for (const [originalName, camelName] of Object.entries(paramMappings)) {
            // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
            if (originalName in normalized && !(camelName in normalized)) {
                normalized[camelName] = normalized[originalName];
                delete normalized[originalName];
            }
            // Also check for proper camelCase (e.g., 'tweetFields')
            // If it's already in proper camelCase, keep it (no conversion needed)
            // The camelName is already the proper camelCase format
        }
        
        return normalized as T;
    }



    /**
     * Stream 10% sampled Posts
     * Streams a 10% sample of public Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsSample10(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsSample10StreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsSample10');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/sample10/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Posts compliance data
     * Streams all compliance data related to Posts.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsCompliance(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsComplianceStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsCompliance');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/compliance/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Portuguese Posts
     * Streams all public Portuguese-language Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsFirehosePt(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsFirehosePtStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsFirehosePt');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/firehose/stream/lang/pt';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }










    /**
     * Stream all Likes
     * Streams all public Likes in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async likesFirehose(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: LikesFirehoseStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'likesFirehose');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'like_with_tweet_author.fields': 'likeWithTweetAuthorFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            likeWithTweetAuthorFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            tweetFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/likes/firehose/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (likeWithTweetAuthorFields !== undefined && likeWithTweetAuthorFields.length > 0) {
            
            params.append('like_with_tweet_author.fields', likeWithTweetAuthorFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream sampled Posts
     * Streams a 1% sample of public Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsSample(
        
        
        
        
        
        
        
        options: PostsSampleStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsSample');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/sample/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }







    /**
     * Stream Korean Posts
     * Streams all public Korean-language Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsFirehoseKo(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsFirehoseKoStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsFirehoseKo');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/firehose/stream/lang/ko';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream sampled Likes
     * Streams a 10% sample of public Likes in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async likesSample10(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: LikesSample10StreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'likesSample10');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'like_with_tweet_author.fields': 'likeWithTweetAuthorFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            likeWithTweetAuthorFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            tweetFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/likes/sample10/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (likeWithTweetAuthorFields !== undefined && likeWithTweetAuthorFields.length > 0) {
            
            params.append('like_with_tweet_author.fields', likeWithTweetAuthorFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream filtered Posts
     * Streams Posts in real-time matching the active rule set.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async posts(
        
        
        
        
        
        
        
        options: PostsStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'posts');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/search/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Likes compliance data
     * Streams all compliance data related to Likes for Users.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async likesCompliance(
        
        
        
        
        
        
        
        options: LikesComplianceStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'likesCompliance');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/likes/compliance/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Users compliance data
     * Streams all compliance data related to Users.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async usersCompliance(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: UsersComplianceStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'usersCompliance');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/compliance/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Post labels
     * Streams all labeling events applied to Posts.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async labelsCompliance(
        
        
        
        
        
        
        
        options: LabelsComplianceStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'labelsCompliance');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/label/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream Japanese Posts
     * Streams all public Japanese-language Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsFirehoseJa(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsFirehoseJaStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsFirehoseJa');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/firehose/stream/lang/ja';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream English Posts
     * Streams all public English-language Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsFirehoseEn(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsFirehoseEnStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsFirehoseEn');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/firehose/stream/lang/en';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }




    /**
     * Stream all Posts
     * Streams all public Posts in real-time.
     * 
     * Returns an event-driven stream that's easy to use.
     * Use .on() to listen for events like 'data', 'error', 'close'.
     * Also supports async iteration with for await...of.



     * @param partition The partition number.



     * @returns {Promise<EventDrivenStream>} Event-driven stream for handling streaming data
     */
    async postsFirehose(
        
        
        
        
        
        partition: number,
        
        
        
        
        
        options: PostsFirehoseStreamingOptions = {}
    ): Promise<EventDrivenStream> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'postsFirehose');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'backfill_minutes': 'backfillMinutes',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            backfillMinutes = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/firehose/stream';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (backfillMinutes !== undefined) {
            
            params.append('backfill_minutes', String(backfillMinutes));
            
        }
        
        
        
        
        
        
        
        
        if (partition !== undefined) {
            params.append('partition', String(partition));
        }
        
        
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            params.append('tweet.fields', tweetFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            params.append('expansions', expansions.join(','));
            
        }
        
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            params.append('media.fields', mediaFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            params.append('poll.fields', pollFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            params.append('user.fields', userFields.join(','));
            
        }
        
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            params.append('place.fields', placeFields.join(','));
            
        }
        
        
        

        // Make the authenticated request using the main client's request method
        // We need raw: true to get the raw Response object for streaming
        const url = path + (params.toString() ? `?${params.toString()}` : '');
        
        // For streaming requests, we don't want to timeout the initial connection
        // Instead, we'll handle timeouts at the stream level
        const response = await this.client.request(
            'GET',
            url,
            {
                headers: {
                    'Content-Type': 'application/json',
                    ...headers,
                },
                
                
                // Pass security requirements for smart auth selection
                security: [
                    
                    {
                        
                        'BearerToken': [],
                        
                    }
                    
                ],
                
                signal: signal,
                raw: true, // Get raw Response object for streaming
                timeout: 0, // Disable timeout for streaming requests
                ...requestOptions,
            }
        ) as Response;

        // Handle errors
        if (!response.ok) {
            throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
            );
        }

        // Return the readable stream
        // The response.body is the actual ReadableStream for streaming
        if (!response.body) {
            throw new Error('Response body is not available for streaming');
        }

        // Wrap the ReadableStream in an event-driven interface
        const eventStream = new EventDrivenStream();
        await eventStream.connect(response.body);
        return eventStream;
    }












    /**
     * Get stream rules
     * Retrieves the active rule set or a subset of rules for the filtered stream.
     * 
     * @returns Promise with the API response
     */
    async getRules(
        
        
        
        
        
        
        
        options: GetRulesStreamingOptions = {}
    ): Promise<GetRulesResponse> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'getRules');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            ids = [],
            
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/search/stream/rules';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (ids !== undefined && ids.length > 0) {
            
            params.append('ids', ids.join(','));
            
        }
        
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...headers,
            },
            signal: signal,
            
            ...requestOptions,
        };

        // Make the request
        return this.client.request<GetRulesResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }



    /**
     * Update stream rules
     * Adds or deletes rules from the active rule set for the filtered stream.
     * 
     * @returns Promise with the API response
     */
    async updateRules(
        
        
        
        
        
        
        body: any,
        
        
        options: UpdateRulesStreamingOptions = {}
    ): Promise<UpdateRulesResponse> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'updateRules');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'dry_run': 'dryRun',
            
            
            
            'delete_all': 'deleteAll',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            dryRun = undefined,
            
            
            
            deleteAll = undefined,
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/search/stream/rules';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (dryRun !== undefined) {
            
            params.append('dry_run', String(dryRun));
            
        }
        
        
        
        
        
        
        
        if (deleteAll !== undefined) {
            
            params.append('delete_all', String(deleteAll));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...headers,
            },
            signal: signal,
            
            body: JSON.stringify(body),
            
            ...requestOptions,
        };

        // Make the request
        return this.client.request<UpdateRulesResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }







    /**
     * Get stream rule counts
     * Retrieves the count of rules in the active rule set for the filtered stream.
     * 
     * @returns Promise with the API response
     */
    async getRuleCounts(
        
        
        
        
        
        
        
        options: GetRuleCountsStreamingOptions = {}
    ): Promise<GetRuleCountsResponse> {
        // Validate authentication requirements
        
        const requiredAuthTypes = [];
        
        
        requiredAuthTypes.push('BearerToken');
        
        
        this.client.validateAuthentication(requiredAuthTypes, 'getRuleCounts');
        

        // Normalize options to handle both camelCase and original API parameter names
        
        const paramMappings: Record<string, string> = {
            
            
            'rules_count.fields': 'rulesCountFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        

        // Destructure options (exclude path parameters, they're already function params)
        
        const {
            
            
            rulesCountFields = [],
            
            
            
            headers = {},
            signal,
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/tweets/search/stream/rules/counts';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        
        if (rulesCountFields !== undefined && rulesCountFields.length > 0) {
            
            params.append('rules_count.fields', rulesCountFields.join(','));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            headers: {
                'Content-Type': 'application/json',
                ...headers,
            },
            signal: signal,
            
            ...requestOptions,
        };

        // Make the request
        return this.client.request<GetRuleCountsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




















}