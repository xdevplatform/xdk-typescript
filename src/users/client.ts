// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.

/**
 * users client for the X API.
 *
 * This module provides a client for interacting with the users endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions, normalizeFields, transformKeysToSnake } from '../client.js';
import { 
    Paginator, 
    PostPaginator, 
    UserPaginator, 
    EventPaginator
} from '../paginator.js';
import {
GetByUsernamesResponse,
GetRepostsOfMeResponse,
UnlikePostResponse,
GetBookmarksResponse,
CreateBookmarkRequest,
CreateBookmarkResponse,
GetFollowersResponse,
UnpinListResponse,
GetByIdResponse,
GetMentionsResponse,
UnrepostPostResponse,
DeleteBookmarkResponse,
UnfollowListResponse,
UnmuteUserResponse,
GetMeResponse,
GetMutingResponse,
MuteUserRequest,
MuteUserResponse,
SearchResponse,
GetBlockingResponse,
GetByIdsResponse,
GetFollowingResponse,
FollowUserRequest,
FollowUserResponse,
LikePostRequest,
LikePostResponse,
GetLikedPostsResponse,
GetPostsResponse,
BlockDmsResponse,
GetListMembershipsResponse,
GetPinnedListsResponse,
PinListRequest,
PinListResponse,
GetByUsernameResponse,
UnfollowUserResponse,
GetTimelineResponse,
GetFollowedListsResponse,
FollowListRequest,
FollowListResponse,
UnblockDmsResponse,
RepostPostRequest,
RepostPostResponse,
GetBookmarkFoldersResponse,
GetOwnedListsResponse,
GetBookmarksByFolderIdResponse,
} from './models.js';


/**
 * Options for getByUsernames method
 * 
 * @public
 */
export interface GetByUsernamesOptions {
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getRepostsOfMe method
 * 
 * @public
 */
export interface GetRepostsOfMeOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getBookmarks method
 * 
 * @public
 */
export interface GetBookmarksOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getFollowers method
 * 
 * @public
 */
export interface GetFollowersOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getById method
 * 
 * @public
 */
export interface GetByIdOptions {
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getMentions method
 * 
 * @public
 */
export interface GetMentionsOptions {
    
    
    /** The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified. 
     * Also accepts: since_id or proper camelCase (e.g., sinceId) */
    sinceId?: string;
    
    
    
    /** The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified. 
     * Also accepts: until_id or proper camelCase (e.g., untilId) */
    untilId?: string;
    
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}






/**
 * Options for getMe method
 * 
 * @public
 */
export interface GetMeOptions {
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getMuting method
 * 
 * @public
 */
export interface GetMutingOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for muteUser method
 * 
 * @public
 */
export interface MuteUserOptions {
    
    
    /** Request body */
    body?: MuteUserRequest;
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for search method
 * 
 * @public
 */
export interface SearchOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase (e.g., nextToken) */
    nextToken?: string;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getBlocking method
 * 
 * @public
 */
export interface GetBlockingOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getByIds method
 * 
 * @public
 */
export interface GetByIdsOptions {
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getFollowing method
 * 
 * @public
 */
export interface GetFollowingOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for followUser method
 * 
 * @public
 */
export interface FollowUserOptions {
    
    
    /** Request body */
    body?: FollowUserRequest;
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for likePost method
 * 
 * @public
 */
export interface LikePostOptions {
    
    
    /** Request body */
    body?: LikePostRequest;
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getLikedPosts method
 * 
 * @public
 */
export interface GetLikedPostsOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getPosts method
 * 
 * @public
 */
export interface GetPostsOptions {
    
    
    /** The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified. 
     * Also accepts: since_id or proper camelCase (e.g., sinceId) */
    sinceId?: string;
    
    
    
    /** The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified. 
     * Also accepts: until_id or proper camelCase (e.g., untilId) */
    untilId?: string;
    
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** The set of entities to exclude (e.g. 'replies' or 'retweets'). 
     * Also accepts: exclude or proper camelCase (e.g., exclude) */
    exclude?: Array<any>;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getListMemberships method
 * 
 * @public
 */
export interface GetListMembershipsOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of List fields to display. 
     * Also accepts: list.fields or proper camelCase (e.g., listFields) */
    listFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getPinnedLists method
 * 
 * @public
 */
export interface GetPinnedListsOptions {
    
    
    /** A comma separated list of List fields to display. 
     * Also accepts: list.fields or proper camelCase (e.g., listFields) */
    listFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getByUsername method
 * 
 * @public
 */
export interface GetByUsernameOptions {
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for getTimeline method
 * 
 * @public
 */
export interface GetTimelineOptions {
    
    
    /** The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified. 
     * Also accepts: since_id or proper camelCase (e.g., sinceId) */
    sinceId?: string;
    
    
    
    /** The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified. 
     * Also accepts: until_id or proper camelCase (e.g., untilId) */
    untilId?: string;
    
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** The set of entities to exclude (e.g. 'replies' or 'retweets'). 
     * Also accepts: exclude or proper camelCase (e.g., exclude) */
    exclude?: Array<any>;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified. 
     * Also accepts: start_time or proper camelCase (e.g., startTime) */
    startTime?: string;
    
    
    
    /** YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified. 
     * Also accepts: end_time or proper camelCase (e.g., endTime) */
    endTime?: string;
    
    
    
    /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase (e.g., tweetFields) */
    tweetFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase (e.g., mediaFields) */
    mediaFields?: Array<any>;
    
    
    
    /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase (e.g., pollFields) */
    pollFields?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase (e.g., placeFields) */
    placeFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getFollowedLists method
 * 
 * @public
 */
export interface GetFollowedListsOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of List fields to display. 
     * Also accepts: list.fields or proper camelCase (e.g., listFields) */
    listFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for followList method
 * 
 * @public
 */
export interface FollowListOptions {
    
    
    /** Request body */
    body?: FollowListRequest;
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}



/**
 * Options for repostPost method
 * 
 * @public
 */
export interface RepostPostOptions {
    
    
    /** Request body */
    body?: RepostPostRequest;
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getBookmarkFolders method
 * 
 * @public
 */
export interface GetBookmarkFoldersOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}


/**
 * Options for getOwnedLists method
 * 
 * @public
 */
export interface GetOwnedListsOptions {
    
    
    /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase (e.g., maxResults) */
    maxResults?: number;
    
    
    
    /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase (e.g., paginationToken) */
    paginationToken?: string;
    
    
    
    /** A comma separated list of List fields to display. 
     * Also accepts: list.fields or proper camelCase (e.g., listFields) */
    listFields?: Array<any>;
    
    
    
    /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase (e.g., expansions) */
    expansions?: Array<any>;
    
    
    
    /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase (e.g., userFields) */
    userFields?: Array<any>;
    
    
    
    /** Additional request options */
    requestOptions?: RequestOptions;
    /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
    [key: string]: any;
}




/**
 * Client for users operations
 * 
 * This client provides methods for interacting with the users endpoints
 * of the X API. It handles authentication, request formatting, and response
 * parsing for all users related operations.
 * 
 * @category users
 */
export class UsersClient {
    private client: Client;

    /**
     * Creates a new users client instance
     * 
     * @param client - The main X API client instance
     */
    constructor(client: Client) {
        this.client = client;
    }

    /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Only accepts: proper camelCase (tweetFields) and original API format (tweet.fields)
     */
    private _normalizeOptions<T extends Record<string, any>>(options: T, paramMappings: Record<string, string>): T {
        if (!options || typeof options !== 'object') {
            return options;
        }
        
        const normalized: any = { ...options };
        
        // For each parameter mapping (original -> proper camelCase)
        for (const [originalName, camelName] of Object.entries(paramMappings)) {
            // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
            if (originalName in normalized && !(camelName in normalized)) {
                normalized[camelName] = normalized[originalName];
                delete normalized[originalName];
            }
            // Also check for proper camelCase (e.g., 'tweetFields')
            // If it's already in proper camelCase, keep it (no conversion needed)
            // The camelName is already the proper camelCase format
        }
        
        return normalized as T;
    }



  /**
   * Get Users by usernames
   * Retrieves details of multiple Users by their usernames.



   * @param usernames A list of usernames, comma-separated.



   * @returns {Promise<GetByUsernamesResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getByUsernames(
        
        
        
        usernames: Array<any>,
        
        
        
        
        options: GetByUsernamesOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getByUsernames(
        
        
        
        usernames: Array<any>,
        
        
        
        
        options?: GetByUsernamesOptions
        
    ): Promise<GetByUsernamesResponse>;
    // Implementation
    async getByUsernames(
        
        
        
        
        
        usernames: Array<any>,
        
        
        
        
        
        
        options: GetByUsernamesOptions = {}
        
    ): Promise<GetByUsernamesResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/by';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (usernames !== undefined && usernames.length > 0) {
            
            
            params.append('usernames', usernames.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetByUsernamesResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Reposts of me
   * Retrieves a list of Posts that repost content from the authenticated user.



   * @returns {Promise<GetRepostsOfMeResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getRepostsOfMe(
        
        
        
        
        options: GetRepostsOfMeOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getRepostsOfMe(
        
        
        
        
        options?: GetRepostsOfMeOptions
        
    ): Promise<GetRepostsOfMeResponse>;
    // Implementation
    async getRepostsOfMe(
        
        
        
        
        
        
        
        
        options: GetRepostsOfMeOptions = {}
        
    ): Promise<GetRepostsOfMeResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/reposts_of_me';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['timeline.read', 'tweet.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetRepostsOfMeResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unlike Post
   * Causes the authenticated user to Unlike a specific Post by its ID.


   * @param id The ID of the authenticated source User that is requesting to unlike the Post.



   * @param tweetId The ID of the Post that the User is requesting to unlike.




   * @returns {Promise<UnlikePostResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unlikePost(
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unlikePost(
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
    ): Promise<UnlikePostResponse>;
    // Implementation
    async unlikePost(
        
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnlikePostResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/likes/{tweet_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{tweet_id}', encodeURIComponent(String(tweetId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['like.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnlikePostResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Bookmarks
   * Retrieves a list of Posts bookmarked by the authenticated user.


   * @param id The ID of the authenticated source User for whom to return results.




   * @returns {Promise<GetBookmarksResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getBookmarks(
        
        
        id: string,
        
        
        
        
        
        options: GetBookmarksOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getBookmarks(
        
        
        id: string,
        
        
        
        
        
        options?: GetBookmarksOptions
        
    ): Promise<GetBookmarksResponse>;
    // Implementation
    async getBookmarks(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetBookmarksOptions = {}
        
    ): Promise<GetBookmarksResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/bookmarks';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['bookmark.read', 'tweet.read', 'users.read'],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetBookmarksResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Create Bookmark
   * Adds a post to the authenticated users bookmarks.


   * @param id The ID of the authenticated source User for whom to add bookmarks.




   * @param body Request body

   * @returns {Promise<CreateBookmarkResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    createBookmark(
        
        
        id: string,
        
        
        
        
        body: CreateBookmarkRequest,
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    createBookmark(
        
        
        id: string,
        
        
        
        
        body: CreateBookmarkRequest,
        
        
    ): Promise<CreateBookmarkResponse>;
    // Implementation
    async createBookmark(
        
        
        
        id: string,
        
        
        
        
        
        
        body: CreateBookmarkRequest,
        
        
        
    ): Promise<CreateBookmarkResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/bookmarks';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: JSON.stringify(transformKeysToSnake(body || {})),
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['bookmark.write', 'tweet.read', 'users.read'],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<CreateBookmarkResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get followers
   * Retrieves a list of Users who follow a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetFollowersResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getFollowers(
        
        
        id: string,
        
        
        
        
        
        options: GetFollowersOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getFollowers(
        
        
        id: string,
        
        
        
        
        
        options?: GetFollowersOptions
        
    ): Promise<GetFollowersResponse>;
    // Implementation
    async getFollowers(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetFollowersOptions = {}
        
    ): Promise<GetFollowersResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/followers';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['follows.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetFollowersResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unpin List
   * Causes the authenticated user to unpin a specific List by its ID.


   * @param id The ID of the authenticated source User for whom to return results.



   * @param listId The ID of the List to unpin.




   * @returns {Promise<UnpinListResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unpinList(
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unpinList(
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
    ): Promise<UnpinListResponse>;
    // Implementation
    async unpinList(
        
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnpinListResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/pinned_lists/{list_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{list_id}', encodeURIComponent(String(listId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['list.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnpinListResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get User by ID
   * Retrieves details of a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetByIdResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getById(
        
        
        id: string,
        
        
        
        
        
        options: GetByIdOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getById(
        
        
        id: string,
        
        
        
        
        
        options?: GetByIdOptions
        
    ): Promise<GetByIdResponse>;
    // Implementation
    async getById(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetByIdOptions = {}
        
    ): Promise<GetByIdResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetByIdResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get mentions
   * Retrieves a list of Posts that mention a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetMentionsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getMentions(
        
        
        id: string,
        
        
        
        
        
        options: GetMentionsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getMentions(
        
        
        id: string,
        
        
        
        
        
        options?: GetMentionsOptions
        
    ): Promise<GetMentionsResponse>;
    // Implementation
    async getMentions(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetMentionsOptions = {}
        
    ): Promise<GetMentionsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'since_id': 'sinceId',
            
            
            
            'until_id': 'untilId',
            
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            sinceId = undefined,
            
            
            
            untilId = undefined,
            
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/mentions';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (sinceId !== undefined) {
            
            params.append('since_id', String(sinceId));
            
        }
        
        
        
        
        
        
        if (untilId !== undefined) {
            
            params.append('until_id', String(untilId));
            
        }
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetMentionsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unrepost Post
   * Causes the authenticated user to unrepost a specific Post by its ID.


   * @param id The ID of the authenticated source User that is requesting to repost the Post.



   * @param sourceTweetId The ID of the Post that the User is requesting to unretweet.




   * @returns {Promise<UnrepostPostResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unrepostPost(
        
        
        id: string,
        
        
        
        sourceTweetId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unrepostPost(
        
        
        id: string,
        
        
        
        sourceTweetId: string,
        
        
        
        
        
    ): Promise<UnrepostPostResponse>;
    // Implementation
    async unrepostPost(
        
        
        
        id: string,
        
        
        
        sourceTweetId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnrepostPostResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/retweets/{source_tweet_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{source_tweet_id}', encodeURIComponent(String(sourceTweetId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'tweet.write', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnrepostPostResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Delete Bookmark
   * Removes a Post from the authenticated users Bookmarks by its ID.


   * @param id The ID of the authenticated source User whose bookmark is to be removed.



   * @param tweetId The ID of the Post that the source User is removing from bookmarks.




   * @returns {Promise<DeleteBookmarkResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    deleteBookmark(
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    deleteBookmark(
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
    ): Promise<DeleteBookmarkResponse>;
    // Implementation
    async deleteBookmark(
        
        
        
        id: string,
        
        
        
        tweetId: string,
        
        
        
        
        
        
        
        
    ): Promise<DeleteBookmarkResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/bookmarks/{tweet_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{tweet_id}', encodeURIComponent(String(tweetId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['bookmark.write', 'tweet.read', 'users.read'],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<DeleteBookmarkResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unfollow List
   * Causes the authenticated user to unfollow a specific List by its ID.


   * @param id The ID of the authenticated source User that will unfollow the List.



   * @param listId The ID of the List to unfollow.




   * @returns {Promise<UnfollowListResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unfollowList(
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unfollowList(
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
    ): Promise<UnfollowListResponse>;
    // Implementation
    async unfollowList(
        
        
        
        id: string,
        
        
        
        listId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnfollowListResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/followed_lists/{list_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{list_id}', encodeURIComponent(String(listId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['list.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnfollowListResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unmute User
   * Causes the authenticated user to unmute a specific user by their ID.


   * @param sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.



   * @param targetUserId The ID of the User that the source User is requesting to unmute.




   * @returns {Promise<UnmuteUserResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unmuteUser(
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unmuteUser(
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
    ): Promise<UnmuteUserResponse>;
    // Implementation
    async unmuteUser(
        
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnmuteUserResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{source_user_id}/muting/{target_user_id}';
        
        
        path = path.replace('{source_user_id}', encodeURIComponent(String(sourceUserId)));
        
        
        
        path = path.replace('{target_user_id}', encodeURIComponent(String(targetUserId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['mute.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnmuteUserResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get my User
   * Retrieves details of the authenticated user.



   * @returns {Promise<GetMeResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getMe(
        
        
        
        
        options: GetMeOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getMe(
        
        
        
        
        options?: GetMeOptions
        
    ): Promise<GetMeResponse>;
    // Implementation
    async getMe(
        
        
        
        
        
        
        
        
        options: GetMeOptions = {}
        
    ): Promise<GetMeResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/me';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetMeResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get muting
   * Retrieves a list of Users muted by the authenticated user.


   * @param id The ID of the authenticated source User for whom to return results.




   * @returns {Promise<GetMutingResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getMuting(
        
        
        id: string,
        
        
        
        
        
        options: GetMutingOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getMuting(
        
        
        id: string,
        
        
        
        
        
        options?: GetMutingOptions
        
    ): Promise<GetMutingResponse>;
    // Implementation
    async getMuting(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetMutingOptions = {}
        
    ): Promise<GetMutingResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/muting';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['mute.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetMutingResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Mute User
   * Causes the authenticated user to mute a specific User by their ID.


   * @param id The ID of the authenticated source User that is requesting to mute the target User.




   * @returns {Promise<MuteUserResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    muteUser(
        
        
        id: string,
        
        
        
        
        
        options: MuteUserOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    muteUser(
        
        
        id: string,
        
        
        
        
        
        options?: MuteUserOptions
        
    ): Promise<MuteUserResponse>;
    // Implementation
    async muteUser(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: MuteUserOptions = {}
        
    ): Promise<MuteUserResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const normalizedOptions = options || {};
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            body,
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/muting';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: body ? JSON.stringify(transformKeysToSnake(body)) : undefined,
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['mute.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<MuteUserResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Search Users
   * Retrieves a list of Users matching a search query.



   * @param query TThe the query string by which to query for users.



   * @returns {Promise<SearchResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    search(
        
        
        
        query: string,
        
        
        
        
        options: SearchOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    search(
        
        
        
        query: string,
        
        
        
        
        options?: SearchOptions
        
    ): Promise<SearchResponse>;
    // Implementation
    async search(
        
        
        
        
        
        query: string,
        
        
        
        
        
        
        options: SearchOptions = {}
        
    ): Promise<SearchResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'next_token': 'nextToken',
            
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            nextToken = undefined,
            
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/search';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (query !== undefined) {
            
            params.append('query', String(query));
            
        }
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (nextToken !== undefined) {
            
            params.append('next_token', String(nextToken));
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<SearchResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get blocking
   * Retrieves a list of Users blocked by the specified User ID.


   * @param id The ID of the authenticated source User for whom to return results.




   * @returns {Promise<GetBlockingResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getBlocking(
        
        
        id: string,
        
        
        
        
        
        options: GetBlockingOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getBlocking(
        
        
        id: string,
        
        
        
        
        
        options?: GetBlockingOptions
        
    ): Promise<GetBlockingResponse>;
    // Implementation
    async getBlocking(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetBlockingOptions = {}
        
    ): Promise<GetBlockingResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/blocking';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['block.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetBlockingResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Users by IDs
   * Retrieves details of multiple Users by their IDs.



   * @param ids A list of User IDs, comma-separated. You can specify up to 100 IDs.



   * @returns {Promise<GetByIdsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getByIds(
        
        
        
        ids: Array<any>,
        
        
        
        
        options: GetByIdsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getByIds(
        
        
        
        ids: Array<any>,
        
        
        
        
        options?: GetByIdsOptions
        
    ): Promise<GetByIdsResponse>;
    // Implementation
    async getByIds(
        
        
        
        
        
        ids: Array<any>,
        
        
        
        
        
        
        options: GetByIdsOptions = {}
        
    ): Promise<GetByIdsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users';
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (ids !== undefined && ids.length > 0) {
            
            
            params.append('ids', ids.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetByIdsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get following
   * Retrieves a list of Users followed by a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetFollowingResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getFollowing(
        
        
        id: string,
        
        
        
        
        
        options: GetFollowingOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getFollowing(
        
        
        id: string,
        
        
        
        
        
        options?: GetFollowingOptions
        
    ): Promise<GetFollowingResponse>;
    // Implementation
    async getFollowing(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetFollowingOptions = {}
        
    ): Promise<GetFollowingResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/following';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['follows.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetFollowingResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Follow User
   * Causes the authenticated user to follow a specific user by their ID.


   * @param id The ID of the authenticated source User that is requesting to follow the target User.




   * @returns {Promise<FollowUserResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    followUser(
        
        
        id: string,
        
        
        
        
        
        options: FollowUserOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    followUser(
        
        
        id: string,
        
        
        
        
        
        options?: FollowUserOptions
        
    ): Promise<FollowUserResponse>;
    // Implementation
    async followUser(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: FollowUserOptions = {}
        
    ): Promise<FollowUserResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const normalizedOptions = options || {};
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            body,
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/following';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: body ? JSON.stringify(transformKeysToSnake(body)) : undefined,
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['follows.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<FollowUserResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Like Post
   * Causes the authenticated user to Like a specific Post by its ID.


   * @param id The ID of the authenticated source User that is requesting to like the Post.




   * @returns {Promise<LikePostResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    likePost(
        
        
        id: string,
        
        
        
        
        
        options: LikePostOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    likePost(
        
        
        id: string,
        
        
        
        
        
        options?: LikePostOptions
        
    ): Promise<LikePostResponse>;
    // Implementation
    async likePost(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: LikePostOptions = {}
        
    ): Promise<LikePostResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const normalizedOptions = options || {};
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            body,
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/likes';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: body ? JSON.stringify(transformKeysToSnake(body)) : undefined,
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['like.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<LikePostResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get liked Posts
   * Retrieves a list of Posts liked by a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetLikedPostsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getLikedPosts(
        
        
        id: string,
        
        
        
        
        
        options: GetLikedPostsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getLikedPosts(
        
        
        id: string,
        
        
        
        
        
        options?: GetLikedPostsOptions
        
    ): Promise<GetLikedPostsResponse>;
    // Implementation
    async getLikedPosts(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetLikedPostsOptions = {}
        
    ): Promise<GetLikedPostsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/liked_tweets';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['like.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetLikedPostsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Posts
   * Retrieves a list of posts authored by a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetPostsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getPosts(
        
        
        id: string,
        
        
        
        
        
        options: GetPostsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getPosts(
        
        
        id: string,
        
        
        
        
        
        options?: GetPostsOptions
        
    ): Promise<GetPostsResponse>;
    // Implementation
    async getPosts(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetPostsOptions = {}
        
    ): Promise<GetPostsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'since_id': 'sinceId',
            
            
            
            'until_id': 'untilId',
            
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            sinceId = undefined,
            
            
            
            untilId = undefined,
            
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            exclude = [],
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/tweets';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (sinceId !== undefined) {
            
            params.append('since_id', String(sinceId));
            
        }
        
        
        
        
        
        
        if (untilId !== undefined) {
            
            params.append('until_id', String(untilId));
            
        }
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (exclude !== undefined && exclude.length > 0) {
            
            
            params.append('exclude', exclude.join(','));
            
            
        }
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetPostsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Block DMs
   * Blocks direct messages to or from a specific User by their ID for the authenticated user.


   * @param id The ID of the target User that the authenticated user requesting to block dms for.




   * @returns {Promise<BlockDmsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    blockDms(
        
        
        id: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    blockDms(
        
        
        id: string,
        
        
        
        
        
    ): Promise<BlockDmsResponse>;
    // Implementation
    async blockDms(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
    ): Promise<BlockDmsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/dm/block';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['dm.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<BlockDmsResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get List memberships
   * Retrieves a list of Lists that a specific User is a member of by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetListMembershipsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getListMemberships(
        
        
        id: string,
        
        
        
        
        
        options: GetListMembershipsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getListMemberships(
        
        
        id: string,
        
        
        
        
        
        options?: GetListMembershipsOptions
        
    ): Promise<GetListMembershipsResponse>;
    // Implementation
    async getListMemberships(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetListMembershipsOptions = {}
        
    ): Promise<GetListMembershipsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'list.fields': 'listFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            listFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/list_memberships';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (listFields !== undefined && listFields.length > 0) {
            
            
            params.append('list.fields', normalizeFields(listFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['list.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetListMembershipsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get pinned Lists
   * Retrieves a list of Lists pinned by the authenticated user.


   * @param id The ID of the authenticated source User for whom to return results.




   * @returns {Promise<GetPinnedListsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getPinnedLists(
        
        
        id: string,
        
        
        
        
        
        options: GetPinnedListsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getPinnedLists(
        
        
        id: string,
        
        
        
        
        
        options?: GetPinnedListsOptions
        
    ): Promise<GetPinnedListsResponse>;
    // Implementation
    async getPinnedLists(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetPinnedListsOptions = {}
        
    ): Promise<GetPinnedListsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'list.fields': 'listFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            listFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/pinned_lists';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (listFields !== undefined && listFields.length > 0) {
            
            
            params.append('list.fields', normalizeFields(listFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['list.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetPinnedListsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Pin List
   * Causes the authenticated user to pin a specific List by its ID.


   * @param id The ID of the authenticated source User that will pin the List.




   * @param body Request body

   * @returns {Promise<PinListResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    pinList(
        
        
        id: string,
        
        
        
        
        body: PinListRequest,
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    pinList(
        
        
        id: string,
        
        
        
        
        body: PinListRequest,
        
        
    ): Promise<PinListResponse>;
    // Implementation
    async pinList(
        
        
        
        id: string,
        
        
        
        
        
        
        body: PinListRequest,
        
        
        
    ): Promise<PinListResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/pinned_lists';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: JSON.stringify(transformKeysToSnake(body || {})),
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['list.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<PinListResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get User by username
   * Retrieves details of a specific User by their username.


   * @param username A username.




   * @returns {Promise<GetByUsernameResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getByUsername(
        
        
        username: string,
        
        
        
        
        
        options: GetByUsernameOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getByUsername(
        
        
        username: string,
        
        
        
        
        
        options?: GetByUsernameOptions
        
    ): Promise<GetByUsernameResponse>;
    // Implementation
    async getByUsername(
        
        
        
        username: string,
        
        
        
        
        
        
        
        
        options: GetByUsernameOptions = {}
        
    ): Promise<GetByUsernameResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'user.fields': 'userFields',
            
            
            
            
            
            'tweet.fields': 'tweetFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            userFields = [],
            
            
            
            expansions = [],
            
            
            
            tweetFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/by/username/{username}';
        
        
        path = path.replace('{username}', encodeURIComponent(String(username)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetByUsernameResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unfollow User
   * Causes the authenticated user to unfollow a specific user by their ID.


   * @param sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.



   * @param targetUserId The ID of the User that the source User is requesting to unfollow.




   * @returns {Promise<UnfollowUserResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unfollowUser(
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unfollowUser(
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
    ): Promise<UnfollowUserResponse>;
    // Implementation
    async unfollowUser(
        
        
        
        sourceUserId: string,
        
        
        
        targetUserId: string,
        
        
        
        
        
        
        
        
    ): Promise<UnfollowUserResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{source_user_id}/following/{target_user_id}';
        
        
        path = path.replace('{source_user_id}', encodeURIComponent(String(sourceUserId)));
        
        
        
        path = path.replace('{target_user_id}', encodeURIComponent(String(targetUserId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['follows.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnfollowUserResponse>(
            'DELETE',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Timeline
   * Retrieves a reverse chronological list of Posts in the authenticated Users Timeline.


   * @param id The ID of the authenticated source User to list Reverse Chronological Timeline Posts of.




   * @returns {Promise<GetTimelineResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getTimeline(
        
        
        id: string,
        
        
        
        
        
        options: GetTimelineOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getTimeline(
        
        
        id: string,
        
        
        
        
        
        options?: GetTimelineOptions
        
    ): Promise<GetTimelineResponse>;
    // Implementation
    async getTimeline(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetTimelineOptions = {}
        
    ): Promise<GetTimelineResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'since_id': 'sinceId',
            
            
            
            'until_id': 'untilId',
            
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            
            
            'start_time': 'startTime',
            
            
            
            'end_time': 'endTime',
            
            
            
            'tweet.fields': 'tweetFields',
            
            
            
            
            
            'media.fields': 'mediaFields',
            
            
            
            'poll.fields': 'pollFields',
            
            
            
            'user.fields': 'userFields',
            
            
            
            'place.fields': 'placeFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            sinceId = undefined,
            
            
            
            untilId = undefined,
            
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            exclude = [],
            
            
            
            startTime = undefined,
            
            
            
            endTime = undefined,
            
            
            
            tweetFields = [],
            
            
            
            expansions = [],
            
            
            
            mediaFields = [],
            
            
            
            pollFields = [],
            
            
            
            userFields = [],
            
            
            
            placeFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/timelines/reverse_chronological';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (sinceId !== undefined) {
            
            params.append('since_id', String(sinceId));
            
        }
        
        
        
        
        
        
        if (untilId !== undefined) {
            
            params.append('until_id', String(untilId));
            
        }
        
        
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (exclude !== undefined && exclude.length > 0) {
            
            
            params.append('exclude', exclude.join(','));
            
            
        }
        
        
        
        
        
        
        if (startTime !== undefined) {
            
            params.append('start_time', String(startTime));
            
        }
        
        
        
        
        
        
        if (endTime !== undefined) {
            
            params.append('end_time', String(endTime));
            
        }
        
        
        
        
        
        
        if (tweetFields !== undefined && tweetFields.length > 0) {
            
            
            params.append('tweet.fields', normalizeFields(tweetFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (mediaFields !== undefined && mediaFields.length > 0) {
            
            
            params.append('media.fields', normalizeFields(mediaFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (pollFields !== undefined && pollFields.length > 0) {
            
            
            params.append('poll.fields', normalizeFields(pollFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (placeFields !== undefined && placeFields.length > 0) {
            
            
            params.append('place.fields', normalizeFields(placeFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetTimelineResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get followed Lists
   * Retrieves a list of Lists followed by a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetFollowedListsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getFollowedLists(
        
        
        id: string,
        
        
        
        
        
        options: GetFollowedListsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getFollowedLists(
        
        
        id: string,
        
        
        
        
        
        options?: GetFollowedListsOptions
        
    ): Promise<GetFollowedListsResponse>;
    // Implementation
    async getFollowedLists(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetFollowedListsOptions = {}
        
    ): Promise<GetFollowedListsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'list.fields': 'listFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            listFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/followed_lists';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (listFields !== undefined && listFields.length > 0) {
            
            
            params.append('list.fields', normalizeFields(listFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['list.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetFollowedListsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Follow List
   * Causes the authenticated user to follow a specific List by its ID.


   * @param id The ID of the authenticated source User that will follow the List.




   * @returns {Promise<FollowListResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    followList(
        
        
        id: string,
        
        
        
        
        
        options: FollowListOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    followList(
        
        
        id: string,
        
        
        
        
        
        options?: FollowListOptions
        
    ): Promise<FollowListResponse>;
    // Implementation
    async followList(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: FollowListOptions = {}
        
    ): Promise<FollowListResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const normalizedOptions = options || {};
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            body,
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/followed_lists';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: body ? JSON.stringify(transformKeysToSnake(body)) : undefined,
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['list.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<FollowListResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Unblock DMs
   * Unblocks direct messages to or from a specific User by their ID for the authenticated user.


   * @param id The ID of the target User that the authenticated user requesting to unblock dms for.




   * @returns {Promise<UnblockDmsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    unblockDms(
        
        
        id: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    unblockDms(
        
        
        id: string,
        
        
        
        
        
    ): Promise<UnblockDmsResponse>;
    // Implementation
    async unblockDms(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
    ): Promise<UnblockDmsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/dm/unblock';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['dm.write', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<UnblockDmsResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Repost Post
   * Causes the authenticated user to repost a specific Post by its ID.


   * @param id The ID of the authenticated source User that is requesting to repost the Post.




   * @returns {Promise<RepostPostResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    repostPost(
        
        
        id: string,
        
        
        
        
        
        options: RepostPostOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    repostPost(
        
        
        id: string,
        
        
        
        
        
        options?: RepostPostOptions
        
    ): Promise<RepostPostResponse>;
    // Implementation
    async repostPost(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: RepostPostOptions = {}
        
    ): Promise<RepostPostResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const normalizedOptions = options || {};
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            body,
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/retweets';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            body: body ? JSON.stringify(transformKeysToSnake(body)) : undefined,
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['tweet.read', 'tweet.write', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<RepostPostResponse>(
            'POST',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Bookmark folders
   * Retrieves a list of Bookmark folders created by the authenticated user.


   * @param id The ID of the authenticated source User for whom to return results.




   * @returns {Promise<GetBookmarkFoldersResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getBookmarkFolders(
        
        
        id: string,
        
        
        
        
        
        options: GetBookmarkFoldersOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getBookmarkFolders(
        
        
        id: string,
        
        
        
        
        
        options?: GetBookmarkFoldersOptions
        
    ): Promise<GetBookmarkFoldersResponse>;
    // Implementation
    async getBookmarkFolders(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetBookmarkFoldersOptions = {}
        
    ): Promise<GetBookmarkFoldersResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/bookmarks/folders';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['bookmark.read', 'users.read'],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetBookmarkFoldersResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get owned Lists
   * Retrieves a list of Lists owned by a specific User by their ID.


   * @param id The ID of the User to lookup.




   * @returns {Promise<GetOwnedListsResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getOwnedLists(
        
        
        id: string,
        
        
        
        
        
        options: GetOwnedListsOptions & { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getOwnedLists(
        
        
        id: string,
        
        
        
        
        
        options?: GetOwnedListsOptions
        
    ): Promise<GetOwnedListsResponse>;
    // Implementation
    async getOwnedLists(
        
        
        
        id: string,
        
        
        
        
        
        
        
        
        options: GetOwnedListsOptions = {}
        
    ): Promise<GetOwnedListsResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        
        const paramMappings: Record<string, string> = {
            
            
            'max_results': 'maxResults',
            
            
            
            'pagination_token': 'paginationToken',
            
            
            
            'list.fields': 'listFields',
            
            
            
            
            
            'user.fields': 'userFields',
            
            
        };
        const normalizedOptions = this._normalizeOptions(options || {}, paramMappings);
        
        
        // Destructure options (exclude path parameters, they're already function params)
        const {
            
            
            maxResults = undefined,
            
            
            
            paginationToken = undefined,
            
            
            
            listFields = [],
            
            
            
            expansions = [],
            
            
            
            userFields = [],
            
            
            
            requestOptions: requestOptions = {}
        } = normalizedOptions;
        

        // Build the path with path parameters
        let path = '/2/users/{id}/owned_lists';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        
        
        
        
        if (maxResults !== undefined) {
            
            params.append('max_results', String(maxResults));
            
        }
        
        
        
        
        
        
        if (paginationToken !== undefined) {
            
            params.append('pagination_token', String(paginationToken));
            
        }
        
        
        
        
        
        
        if (listFields !== undefined && listFields.length > 0) {
            
            
            params.append('list.fields', normalizeFields(listFields).join(','));
            
            
        }
        
        
        
        
        
        
        if (expansions !== undefined && expansions.length > 0) {
            
            
            params.append('expansions', expansions.join(','));
            
            
        }
        
        
        
        
        
        
        if (userFields !== undefined && userFields.length > 0) {
            
            
            params.append('user.fields', normalizeFields(userFields).join(','));
            
            
        }
        
        
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'BearerToken': [],
                    
                },
                
                {
                    
                    'OAuth2UserToken': ['list.read', 'tweet.read', 'users.read'],
                    
                },
                
                {
                    
                    'UserToken': [],
                    
                }
                
            ],
            
            
            ...requestOptions
            
        };

        return this.client.request<GetOwnedListsResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }




  /**
   * Get Bookmarks by folder ID
   * Retrieves Posts in a specific Bookmark folder by its ID for the authenticated user.


   * @param id The ID of the authenticated source User for whom to return results.



   * @param folderId The ID of the Bookmark Folder that the authenticated User is trying to fetch Posts for.




   * @returns {Promise<GetBookmarksByFolderIdResponse>} Promise resolving to the API response, or raw Response if requestOptions.raw is true
   */
    // Overload 1: raw: true returns Response
    getBookmarksByFolderId(
        
        
        id: string,
        
        
        
        folderId: string,
        
        
        
        
        
        options: { requestOptions: { raw: true } }
        
    ): Promise<Response>;
    // Overload 2: Default behavior returns parsed response
    getBookmarksByFolderId(
        
        
        id: string,
        
        
        
        folderId: string,
        
        
        
        
        
    ): Promise<GetBookmarksByFolderIdResponse>;
    // Implementation
    async getBookmarksByFolderId(
        
        
        
        id: string,
        
        
        
        folderId: string,
        
        
        
        
        
        
        
        
    ): Promise<GetBookmarksByFolderIdResponse | Response> {
        // Normalize options to handle both camelCase and original API parameter names
        
        const requestOptions = {};
        

        // Build the path with path parameters
        let path = '/2/users/{id}/bookmarks/folders/{folder_id}';
        
        
        path = path.replace('{id}', encodeURIComponent(String(id)));
        
        
        
        path = path.replace('{folder_id}', encodeURIComponent(String(folderId)));
        
        

        // Build query parameters
        const params = new URLSearchParams();
        

        // Prepare request options
        const finalRequestOptions: RequestOptions = {
            
            
            // Pass security requirements for smart auth selection
            security: [
                
                {
                    
                    'OAuth2UserToken': ['bookmark.read', 'tweet.read', 'users.read'],
                    
                }
                
            ],
            
            
            // No optional parameters, using empty request options
            
        };

        return this.client.request<GetBookmarksByFolderIdResponse>(
            'GET',
            path + (params.toString() ? `?${params.toString()}` : ''),
            finalRequestOptions
        );
    }

















































































}
