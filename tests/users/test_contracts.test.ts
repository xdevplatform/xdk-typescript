// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for Users client.
 *
 * This module contains tests that validate the request/response contracts
 * of the Users client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { UsersClient } from '../../src/users/client.js';
import { Client } from '../../src/client.js';

describe('UsersClient Contracts', () => {
  let client: Client;
  let usersClient: UsersClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    usersClient = client.users;
  });

  
  it('should have correct request structure for getByUsernames', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getByUsernames'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/by';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByUsernames', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getByUsernames'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByUsernames', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getByUsernames'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getRepostsOfMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getRepostsOfMe'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/reposts_of_me';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getRepostsOfMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getRepostsOfMe'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getRepostsOfMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getRepostsOfMe'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unlikePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unlikePost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/likes/{tweet_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unlikePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unlikePost'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unlikePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unlikePost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getBookmarks', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getBookmarks'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/bookmarks';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getBookmarks', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getBookmarks'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getBookmarks', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getBookmarks'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for createBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['createBookmark'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/bookmarks';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for createBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['createBookmark'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for createBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['createBookmark'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getFollowers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getFollowers'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/followers';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getFollowers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getFollowers'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getFollowers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getFollowers'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unpinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unpinList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/pinned_lists/{list_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unpinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unpinList'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unpinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unpinList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getById'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getById'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getById'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getMentions', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getMentions'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/mentions';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getMentions', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getMentions'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getMentions', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getMentions'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unrepostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unrepostPost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/retweets/{source_tweet_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unrepostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unrepostPost'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unrepostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unrepostPost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for deleteBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['deleteBookmark'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/bookmarks/{tweet_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for deleteBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['deleteBookmark'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for deleteBookmark', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['deleteBookmark'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unfollowList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unfollowList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/followed_lists/{list_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unfollowList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unfollowList'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unfollowList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unfollowList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unmuteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unmuteUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{source_user_id}/muting/{target_user_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unmuteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unmuteUser'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unmuteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unmuteUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getMe'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/me';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getMe'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getMe', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getMe'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getMuting', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getMuting'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/muting';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getMuting', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getMuting'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getMuting', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getMuting'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for muteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['muteUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/muting';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for muteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['muteUser'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for muteUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['muteUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for search', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['search'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/search';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for search', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['search'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for search', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['search'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getBlocking', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getBlocking'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/blocking';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getBlocking', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getBlocking'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getBlocking', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getBlocking'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getByIds'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getByIds'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getByIds'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getFollowing', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getFollowing'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/following';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getFollowing', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getFollowing'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getFollowing', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getFollowing'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for followUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['followUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/following';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for followUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['followUser'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for followUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['followUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for likePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['likePost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/likes';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for likePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['likePost'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for likePost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['likePost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getLikedPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getLikedPosts'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/liked_tweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getLikedPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getLikedPosts'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getLikedPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getLikedPosts'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getPosts'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/tweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getPosts'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getPosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getPosts'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for blockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['blockDms'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/dm/block';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for blockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['blockDms'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for blockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['blockDms'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getListMemberships', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getListMemberships'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/list_memberships';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getListMemberships', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getListMemberships'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getListMemberships', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getListMemberships'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getPinnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getPinnedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/pinned_lists';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getPinnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getPinnedLists'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getPinnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getPinnedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for pinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['pinList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/pinned_lists';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for pinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['pinList'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for pinList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['pinList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByUsername', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_username',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getByUsername'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/by/username/{username}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByUsername', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getByUsername'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_username',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByUsername', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_username',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getByUsername'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unfollowUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unfollowUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{source_user_id}/following/{target_user_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unfollowUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unfollowUser'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unfollowUser', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unfollowUser'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getTimeline', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getTimeline'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/timelines/reverse_chronological';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getTimeline', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getTimeline'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getTimeline', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getTimeline'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getFollowedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getFollowedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/followed_lists';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getFollowedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getFollowedLists'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getFollowedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getFollowedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for followList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['followList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/followed_lists';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for followList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['followList'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for followList', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['followList'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for unblockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['unblockDms'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/dm/unblock';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for unblockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['unblockDms'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for unblockDms', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['unblockDms'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for repostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['repostPost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/retweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for repostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['repostPost'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for repostPost', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['repostPost'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getBookmarkFolders', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getBookmarkFolders'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/bookmarks/folders';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getBookmarkFolders', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getBookmarkFolders'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getBookmarkFolders', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getBookmarkFolders'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getOwnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getOwnedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/owned_lists';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getOwnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getOwnedLists'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getOwnedLists', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getOwnedLists'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getBookmarksByFolderId', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (usersClient as any)['getBookmarksByFolderId'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/{id}/bookmarks/folders/{folder_id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getBookmarksByFolderId', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (usersClient as any)['getBookmarksByFolderId'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(usersClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getBookmarksByFolderId', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (usersClient as any)['getBookmarksByFolderId'];
      const result = await method.apply(usersClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
