// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated structural tests for Activity client.
 *
 * This module contains tests that validate the structure and API surface
 * of the Activity client. These tests ensure that all expected methods
 * exist, have correct signatures, and proper type annotations for robust API contracts.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll } from '@jest/globals';
import { ActivityClient } from '../../src/activity/client.js';
import { Client } from '../../src/client.js';

describe('ActivityClient Structure', () => {
  let client: Client;
  let activityClient: ActivityClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    activityClient = client.activity;
  });

  
  
  it('should have stream method with correct signature', () => {
    // Check method exists
    expect(ActivityClient.prototype).toHaveProperty('stream');
    
    // Check method is callable
    const method = activityClient.stream;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have stream method with return type annotation', () => {
    const method = activityClient.stream;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have getSubscriptions method with correct signature', () => {
    // Check method exists
    expect(ActivityClient.prototype).toHaveProperty('getSubscriptions');
    
    // Check method is callable
    const method = activityClient.getSubscriptions;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getSubscriptions method with return type annotation', () => {
    const method = activityClient.getSubscriptions;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have createSubscription method with correct signature', () => {
    // Check method exists
    expect(ActivityClient.prototype).toHaveProperty('createSubscription');
    
    // Check method is callable
    const method = activityClient.createSubscription;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have createSubscription method with return type annotation', () => {
    const method = activityClient.createSubscription;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have updateSubscription method with correct signature', () => {
    // Check method exists
    expect(ActivityClient.prototype).toHaveProperty('updateSubscription');
    
    // Check method is callable
    const method = activityClient.updateSubscription;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'subscriptionId',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have updateSubscription method with return type annotation', () => {
    const method = activityClient.updateSubscription;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have deleteSubscription method with correct signature', () => {
    // Check method exists
    expect(ActivityClient.prototype).toHaveProperty('deleteSubscription');
    
    // Check method is callable
    const method = activityClient.deleteSubscription;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'subscriptionId',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have deleteSubscription method with return type annotation', () => {
    const method = activityClient.deleteSubscription;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  

  it('should have all expected methods', () => {
    const expectedMethods = [
      
      'stream',
      
      'getSubscriptions',
      
      'createSubscription',
      
      'updateSubscription',
      
      'deleteSubscription',
      
    ];

    for (const expectedMethod of expectedMethods) {
      expect(ActivityClient.prototype).toHaveProperty(expectedMethod);
      const method = (activityClient as any)[expectedMethod];
      expect(typeof method).toBe('function');
    }
  });

  
});
