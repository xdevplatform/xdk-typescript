// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for Trends client.
 *
 * This module contains tests that validate the request/response contracts
 * of the Trends client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { TrendsClient } from '../../src/trends/client.js';
import { Client } from '../../src/client.js';

describe('TrendsClient Contracts', () => {
  let client: Client;
  let trendsClient: TrendsClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    trendsClient = client.trends;
  });

  
  it('should have correct request structure for getPersonalized', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (trendsClient as any)['getPersonalized'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/personalized_trends';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getPersonalized', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (trendsClient as any)['getPersonalized'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(trendsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getPersonalized', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (trendsClient as any)['getPersonalized'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getAi', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (trendsClient as any)['getAi'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/ai_trends/{id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getAi', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (trendsClient as any)['getAi'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(trendsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getAi', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (trendsClient as any)['getAi'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByWoeid', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (trendsClient as any)['getByWoeid'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/trends/by/woeid/{woeid}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByWoeid', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (trendsClient as any)['getByWoeid'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(trendsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByWoeid', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (trendsClient as any)['getByWoeid'];
      const result = await method.apply(trendsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
