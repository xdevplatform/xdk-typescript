// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for Stream client.
 *
 * This module contains tests that validate the request/response contracts
 * of the Stream client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { StreamClient } from '../../src/stream/client.js';
import { Client } from '../../src/client.js';

describe('StreamClient Contracts', () => {
  let client: Client;
  let streamClient: StreamClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    streamClient = client.stream;
  });

  
  it('should have correct request structure for postsFirehoseKo', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsFirehoseKo'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/firehose/stream/lang/ko';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsFirehoseKo', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsFirehoseKo'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsFirehoseKo', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsFirehoseKo'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsSample10'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/sample10/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsSample10'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsSample10'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for posts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['posts'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for posts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['posts'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for posts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['posts'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['getRules'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/stream/rules';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['getRules'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['getRules'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for updateRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['updateRules'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/stream/rules';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for updateRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['updateRules'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for updateRules', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['updateRules'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for likesFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['likesFirehose'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/likes/firehose/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for likesFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['likesFirehose'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for likesFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['likesFirehose'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/compliance/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsCompliance'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsFirehoseJa', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsFirehoseJa'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/firehose/stream/lang/ja';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsFirehoseJa', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsFirehoseJa'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsFirehoseJa', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsFirehoseJa'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for likesCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['likesCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/likes/compliance/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for likesCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['likesCompliance'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for likesCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['likesCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for labelsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['labelsCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/label/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for labelsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['labelsCompliance'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for labelsCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['labelsCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsFirehoseEn', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsFirehoseEn'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/firehose/stream/lang/en';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsFirehoseEn', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsFirehoseEn'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsFirehoseEn', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsFirehoseEn'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsFirehose'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/firehose/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsFirehose'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsFirehose', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsFirehose'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsSample', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsSample'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/sample/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsSample', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsSample'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsSample', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsSample'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getRuleCounts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['getRuleCounts'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/stream/rules/counts';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getRuleCounts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['getRuleCounts'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getRuleCounts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (streamClient as any)['getRuleCounts'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for usersCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['usersCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/users/compliance/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for usersCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['usersCompliance'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for usersCompliance', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['usersCompliance'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for likesSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['likesSample10'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/likes/sample10/stream';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for likesSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['likesSample10'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for likesSample10', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['likesSample10'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for postsFirehosePt', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (streamClient as any)['postsFirehosePt'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/firehose/stream/lang/pt';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for postsFirehosePt', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (streamClient as any)['postsFirehosePt'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(streamClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for postsFirehosePt', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      42,
      
      
      ];
      const options: any = {};

      const method = (streamClient as any)['postsFirehosePt'];
      const result = await method.apply(streamClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        
        expect(result).toHaveProperty('data');
        
      }
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
