// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated pagination tests for CommunityNotes client.
 *
 * This module contains tests that validate pagination functionality
 * using the Paginator class for methods that support pagination. Tests verify
 * proper handling of pagination tokens, page limits, and item iteration.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { CommunityNotesClient } from '../../src/community_notes/client.js';
import { Client } from '../../src/client.js';
import { Paginator } from '../../src/paginator.js';

describe('CommunityNotesClient Pagination', () => {
  let client: Client;
  let communityNotesClient: CommunityNotesClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    communityNotesClient = client.communityNotes;
  });

  
  it('should create paginator for searchWritten', () => {
    const method = (communityNotesClient as any)['searchWritten'];
    
    // Should be able to create paginator without error
    const params: any = {
      
      
      test_mode: true,
      
      
      maxResults: 10
    };
    
    // Note: Paginator creation is typically done through the method itself
    // This test verifies the method supports pagination
    expect(typeof method).toBe('function');
  });

  it('should paginate through pages for searchWritten', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to return paginated responses (like Python mocks session)
    let callCount = 0;
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockImplementation(() => {
      callCount++;
      if (callCount === 1) {
        // First page response
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            data: [
              { id: '1', name: 'Item 1' },
              { id: '2', name: 'Item 2' }
            ],
            meta: {
              
              'next_token': 'next_page_token',
              
              result_count: 2
            }
          }),
          text: async () => '{}'
        } as Response);
      } else {
        // Second page response (no next token = end of pagination)
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            data: [
              { id: '3', name: 'Item 3' }
            ],
            meta: {
              result_count: 1
            }
          }),
          text: async () => '{}'
        } as Response);
      }
    });

    try {
      const method = (communityNotesClient as any)['searchWritten'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      
      
      true,
      
      
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 2
      };

      // Call method and get first page
      const firstPage = await method.apply(communityNotesClient, [...requiredArgs, options]);
      expect(firstPage).toBeDefined();
      expect(firstPage.data).toBeDefined();
      expect(Array.isArray(firstPage.data)).toBe(true);
      expect(firstPage.data.length).toBe(2);

      // If there's a next token, call again with pagination token
      
      if (firstPage.meta && firstPage.meta['next_token']) {
        options.paginationToken = firstPage.meta['next_token'];
        const secondPage = await method.apply(communityNotesClient, [...requiredArgs, options]);
        expect(secondPage).toBeDefined();
        expect(secondPage.data).toBeDefined();
        expect(Array.isArray(secondPage.data)).toBe(true);
      }
      

      // Should have made multiple requests
      expect((client.httpClient.request as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle pagination parameters correctly for searchWritten', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: async () => ({
        data: [],
        meta: { result_count: 0 }
      }),
      text: async () => '{}'
    } as Response);

    try {
      const method = (communityNotesClient as any)['searchWritten'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      
      
      true,
      
      
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 5
      };

      await method.apply(communityNotesClient, [...requiredArgs, options]);

      // Verify maxResults was passed in request (becomes max_results in query string)
      expect(client.httpClient.request).toHaveBeenCalled();
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      // maxResults in options becomes max_results in query string
      expect(url).toMatch(/max_results=5|maxResults=5/);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should create paginator for searchEligiblePosts', () => {
    const method = (communityNotesClient as any)['searchEligiblePosts'];
    
    // Should be able to create paginator without error
    const params: any = {
      
      
      test_mode: true,
      
      
      maxResults: 10
    };
    
    // Note: Paginator creation is typically done through the method itself
    // This test verifies the method supports pagination
    expect(typeof method).toBe('function');
  });

  it('should paginate through pages for searchEligiblePosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to return paginated responses (like Python mocks session)
    let callCount = 0;
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockImplementation(() => {
      callCount++;
      if (callCount === 1) {
        // First page response
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            data: [
              { id: '1', name: 'Item 1' },
              { id: '2', name: 'Item 2' }
            ],
            meta: {
              
              'next_token': 'next_page_token',
              
              result_count: 2
            }
          }),
          text: async () => '{}'
        } as Response);
      } else {
        // Second page response (no next token = end of pagination)
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            data: [
              { id: '3', name: 'Item 3' }
            ],
            meta: {
              result_count: 1
            }
          }),
          text: async () => '{}'
        } as Response);
      }
    });

    try {
      const method = (communityNotesClient as any)['searchEligiblePosts'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      
      
      true,
      
      
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 2
      };

      // Call method and get first page
      const firstPage = await method.apply(communityNotesClient, [...requiredArgs, options]);
      expect(firstPage).toBeDefined();
      expect(firstPage.data).toBeDefined();
      expect(Array.isArray(firstPage.data)).toBe(true);
      expect(firstPage.data.length).toBe(2);

      // If there's a next token, call again with pagination token
      
      if (firstPage.meta && firstPage.meta['next_token']) {
        options.paginationToken = firstPage.meta['next_token'];
        const secondPage = await method.apply(communityNotesClient, [...requiredArgs, options]);
        expect(secondPage).toBeDefined();
        expect(secondPage.data).toBeDefined();
        expect(Array.isArray(secondPage.data)).toBe(true);
      }
      

      // Should have made multiple requests
      expect((client.httpClient.request as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle pagination parameters correctly for searchEligiblePosts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: async () => ({
        data: [],
        meta: { result_count: 0 }
      }),
      text: async () => '{}'
    } as Response);

    try {
      const method = (communityNotesClient as any)['searchEligiblePosts'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      
      
      true,
      
      
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 5
      };

      await method.apply(communityNotesClient, [...requiredArgs, options]);

      // Verify maxResults was passed in request (becomes max_results in query string)
      expect(client.httpClient.request).toHaveBeenCalled();
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      // maxResults in options becomes max_results in query string
      expect(url).toMatch(/max_results=5|maxResults=5/);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
