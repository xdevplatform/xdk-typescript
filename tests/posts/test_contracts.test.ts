// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for Posts client.
 *
 * This module contains tests that validate the request/response contracts
 * of the Posts client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { PostsClient } from '../../src/posts/client.js';
import { Client } from '../../src/client.js';

describe('PostsClient Contracts', () => {
  let client: Client;
  let postsClient: PostsClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    postsClient = client.posts;
  });

  
  it('should have correct request structure for getInsights28hr', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getInsights28hr'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/insights/28hr';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getInsights28hr', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getInsights28hr'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getInsights28hr', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getInsights28hr'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getAnalytics'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/analytics';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getAnalytics'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getAnalytics'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getReposts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getReposts'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}/retweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getReposts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getReposts'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getReposts', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getReposts'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for searchRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['searchRecent'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/recent';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for searchRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['searchRecent'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for searchRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['searchRecent'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for searchAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['searchAll'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/search/all';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for searchAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['searchAll'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for searchAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['searchAll'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getByIds'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getByIds'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByIds', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getByIds'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for create', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['create'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for create', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['create'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for create', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (postsClient as any)['create'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getQuoted', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getQuoted'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}/quote_tweets';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getQuoted', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getQuoted'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getQuoted', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getQuoted'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getCountsRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getCountsRecent'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/counts/recent';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getCountsRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getCountsRecent'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getCountsRecent', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getCountsRecent'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for hideReply', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['hideReply'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{tweet_id}/hidden';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for hideReply', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['hideReply'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for hideReply', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['hideReply'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getInsightsHistorical', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getInsightsHistorical'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/insights/historical';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getInsightsHistorical', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getInsightsHistorical'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getInsightsHistorical', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getInsightsHistorical'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getCountsAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getCountsAll'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/counts/all';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getCountsAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getCountsAll'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getCountsAll', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_query',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getCountsAll'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getById'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getById'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getById', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getById'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for delete', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['delete'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for delete', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['delete'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for delete', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['delete'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getLikingUsers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getLikingUsers'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}/liking_users';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getLikingUsers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getLikingUsers'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getLikingUsers', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getLikingUsers'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getRepostedBy', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (postsClient as any)['getRepostedBy'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/tweets/{id}/retweeted_by';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getRepostedBy', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (postsClient as any)['getRepostedBy'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(postsClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getRepostedBy', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (postsClient as any)['getRepostedBy'];
      const result = await method.apply(postsClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
