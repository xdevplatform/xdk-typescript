// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated structural tests for Posts client.
 *
 * This module contains tests that validate the structure and API surface
 * of the Posts client. These tests ensure that all expected methods
 * exist, have correct signatures, and proper type annotations for robust API contracts.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll } from '@jest/globals';
import { PostsClient } from '../../src/posts/client.js';
import { Client } from '../../src/client.js';

describe('PostsClient Structure', () => {
  let client: Client;
  let postsClient: PostsClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    postsClient = client.posts;
  });

  
  
  it('should have getLikingUsers method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getLikingUsers');
    
    // Check method is callable
    const method = postsClient.getLikingUsers;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getLikingUsers method with return type annotation', () => {
    const method = postsClient.getLikingUsers;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have getLikingUsers method with pagination parameters', () => {
    const method = postsClient.getLikingUsers;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getReposts method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getReposts');
    
    // Check method is callable
    const method = postsClient.getReposts;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getReposts method with return type annotation', () => {
    const method = postsClient.getReposts;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have getReposts method with pagination parameters', () => {
    const method = postsClient.getReposts;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getCountsRecent method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getCountsRecent');
    
    // Check method is callable
    const method = postsClient.getCountsRecent;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'query',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getCountsRecent method with return type annotation', () => {
    const method = postsClient.getCountsRecent;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have hideReply method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('hideReply');
    
    // Check method is callable
    const method = postsClient.hideReply;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'tweetId',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have hideReply method with return type annotation', () => {
    const method = postsClient.hideReply;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have searchAll method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('searchAll');
    
    // Check method is callable
    const method = postsClient.searchAll;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'query',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have searchAll method with return type annotation', () => {
    const method = postsClient.searchAll;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have searchAll method with pagination parameters', () => {
    const method = postsClient.searchAll;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getByIds method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getByIds');
    
    // Check method is callable
    const method = postsClient.getByIds;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'ids',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getByIds method with return type annotation', () => {
    const method = postsClient.getByIds;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have create method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('create');
    
    // Check method is callable
    const method = postsClient.create;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have create method with return type annotation', () => {
    const method = postsClient.create;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have getCountsAll method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getCountsAll');
    
    // Check method is callable
    const method = postsClient.getCountsAll;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'query',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getCountsAll method with return type annotation', () => {
    const method = postsClient.getCountsAll;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have getById method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getById');
    
    // Check method is callable
    const method = postsClient.getById;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getById method with return type annotation', () => {
    const method = postsClient.getById;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have delete method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('delete');
    
    // Check method is callable
    const method = postsClient.delete;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have delete method with return type annotation', () => {
    const method = postsClient.delete;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have getRepostedBy method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getRepostedBy');
    
    // Check method is callable
    const method = postsClient.getRepostedBy;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getRepostedBy method with return type annotation', () => {
    const method = postsClient.getRepostedBy;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have getRepostedBy method with pagination parameters', () => {
    const method = postsClient.getRepostedBy;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getInsights28hr method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getInsights28hr');
    
    // Check method is callable
    const method = postsClient.getInsights28hr;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'tweetIds',
      
      'granularity',
      
      'requestedMetrics',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getInsights28hr method with return type annotation', () => {
    const method = postsClient.getInsights28hr;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have getInsightsHistorical method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getInsightsHistorical');
    
    // Check method is callable
    const method = postsClient.getInsightsHistorical;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'tweetIds',
      
      'endTime',
      
      'startTime',
      
      'granularity',
      
      'requestedMetrics',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getInsightsHistorical method with return type annotation', () => {
    const method = postsClient.getInsightsHistorical;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  
  it('should have searchRecent method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('searchRecent');
    
    // Check method is callable
    const method = postsClient.searchRecent;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'query',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have searchRecent method with return type annotation', () => {
    const method = postsClient.searchRecent;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have searchRecent method with pagination parameters', () => {
    const method = postsClient.searchRecent;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getQuoted method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getQuoted');
    
    // Check method is callable
    const method = postsClient.getQuoted;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'id',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getQuoted method with return type annotation', () => {
    const method = postsClient.getQuoted;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  
  it('should have getQuoted method with pagination parameters', () => {
    const method = postsClient.getQuoted;
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Should have pagination-related parameters (check for common pagination param names)
    const paginationKeywords = ['pagination', 'token', 'max', 'results', 'next', 'cursor', 'limit', 'page'];
    const hasPaginationParam = paginationKeywords.some(keyword => 
      params.some(p => p.toLowerCase().includes(keyword.toLowerCase()))
    );
    // Note: Some pagination methods may use options object instead of individual params
    // This test is lenient to account for different pagination patterns
    if (params.length > 0) {
      expect(hasPaginationParam || params.some(p => p.includes('options'))).toBe(true);
    }
  });
  

  
  it('should have getAnalytics method with correct signature', () => {
    // Check method exists
    expect(PostsClient.prototype).toHaveProperty('getAnalytics');
    
    // Check method is callable
    const method = postsClient.getAnalytics;
    expect(typeof method).toBe('function');
    
    // Check method signature by examining parameter count
    const methodString = method.toString();
    const paramsMatch = methodString.match(/\(([^)]*)\)/);
    const params = paramsMatch ? paramsMatch[1].split(',').map(p => p.trim().split(':')[0].trim()).filter(p => p) : [];
    
    // Check required parameters exist (convert to camelCase for TypeScript)
    const requiredParams = [
      
      'ids',
      
      'endTime',
      
      'startTime',
      
      'granularity',
      
    ];
    
    for (const requiredParam of requiredParams) {
      // Check if parameter exists (may be in camelCase or snake_case)
      const paramExists = params.some(p => 
        p === requiredParam || 
        p.toLowerCase() === requiredParam.toLowerCase() ||
        p.replace(/_/g, '') === requiredParam.replace(/_/g, '')
      );
      expect(paramExists).toBe(true);
    }
  });

  it('should have getAnalytics method with return type annotation', () => {
    const method = postsClient.getAnalytics;
    expect(typeof method).toBe('function');
    // TypeScript will enforce return types at compile time
    // This test ensures the method exists and is callable
  });

  

  

  it('should have all expected methods', () => {
    const expectedMethods = [
      
      'getLikingUsers',
      
      'getReposts',
      
      'getCountsRecent',
      
      'hideReply',
      
      'searchAll',
      
      'getByIds',
      
      'create',
      
      'getCountsAll',
      
      'getById',
      
      'delete',
      
      'getRepostedBy',
      
      'getInsights28hr',
      
      'getInsightsHistorical',
      
      'searchRecent',
      
      'getQuoted',
      
      'getAnalytics',
      
    ];

    for (const expectedMethod of expectedMethods) {
      expect(PostsClient.prototype).toHaveProperty(expectedMethod);
      const method = (postsClient as any)[expectedMethod];
      expect(typeof method).toBe('function');
    }
  });

  
});
