// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for Media client.
 *
 * This module contains tests that validate the request/response contracts
 * of the Media client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { MediaClient } from '../../src/media/client.js';
import { Client } from '../../src/client.js';

describe('MediaClient Contracts', () => {
  let client: Client;
  let mediaClient: MediaClient;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    mediaClient = client.media;
  });

  
  it('should have correct request structure for createSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['createSubtitles'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/subtitles';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for createSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['createSubtitles'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for createSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['createSubtitles'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for deleteSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['deleteSubtitles'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/subtitles';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for deleteSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['deleteSubtitles'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for deleteSubtitles', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['deleteSubtitles'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for finalizeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['finalizeUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/upload/{id}/finalize';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for finalizeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['finalizeUpload'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for finalizeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['finalizeUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for initializeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['initializeUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/upload/initialize';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for initializeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['initializeUpload'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for initializeUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['initializeUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for appendUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['appendUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/upload/{id}/append';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for appendUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['appendUpload'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for appendUpload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['appendUpload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByKeys', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['getByKeys'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByKeys', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['getByKeys'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByKeys', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['getByKeys'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getByKey', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['getByKey'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/{media_key}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getByKey', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['getByKey'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getByKey', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['getByKey'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for createMetadata', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['createMetadata'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/metadata';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for createMetadata', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['createMetadata'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for createMetadata', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['createMetadata'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['getAnalytics'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/analytics';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['getAnalytics'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getAnalytics', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      ['test_item'],
      
      
      
      'test_end_time',
      
      
      
      'test_start_time',
      
      
      
      'test_granularity',
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['getAnalytics'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for getUploadStatus', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['getUploadStatus'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/upload';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for getUploadStatus', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['getUploadStatus'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for getUploadStatus', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      
      'test_value',
      
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['getUploadStatus'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
  it('should have correct request structure for upload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({
        
        
        data: null,
        
        
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = (mediaClient as any)['upload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '/2/media/upload';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for upload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = (mediaClient as any)['upload'];
      
      
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply(mediaClient, [...requiredArgs, options])).resolves.toBeDefined();
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for upload', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      
      
      data: null,
      
      
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      
      ];
      const options: any = {};

      const method = (mediaClient as any)['upload'];
      const result = await method.apply(mediaClient, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      
      // Regular JSON response - check for expected fields
      
      expect(result).toHaveProperty('data');
      
      
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  
});
